{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Extraction Methods","text":"<p>Extraction methods provide a set of methods to extract and manipulate metadata dictionaries. The framework leverages a modular, plugin architecture to allow users to modify the workflow to fit their needs.</p>"},{"location":"bbox/","title":"Bbox","text":""},{"location":"bbox/#extraction_methods.plugins.bbox.BboxExtract","title":"<code>BboxExtract</code>","text":"<p>               Bases: <code>ExtractionMethod</code></p> <p>Method name: <code>bbox</code></p> <p>Converts a coordinate values to <code>RFC 7946, section 5 &lt;https://tools.ietf.org/html/rfc7946#section-5&gt;</code>_ formatted bbox.</p> Example Configuration <p>.. code-block:: yaml</p> <pre><code>- method: bbox\n  inputs:\n    west: 0\n    south: 0\n    east: $east_variable\n    north: $north_variable\n</code></pre> Source code in <code>extraction_methods/plugins/bbox.py</code> <pre><code>class BboxExtract(ExtractionMethod):\n    \"\"\"\n\n    **Method name:** ``bbox``\n\n    Converts a coordinate values to `RFC 7946,\n    section 5 &lt;https://tools.ietf.org/html/rfc7946#section-5&gt;`_ formatted bbox.\n\n    Example Configuration:\n        .. code-block:: yaml\n\n            - method: bbox\n              inputs:\n                west: 0\n                south: 0\n                east: $east_variable\n                north: $north_variable\n    \"\"\"\n\n    input_class = BboxInput\n\n    @update_input\n    def run(self, body: dict[str, Any]) -&gt; dict[str, Any]:\n\n        try:\n            body[\"bbox\"] = {\n                \"type\": \"envelope\",\n                \"coordinates\": [\n                    [\n                        float(self.input.west),\n                        float(self.input.south),\n                    ],\n                    [\n                        float(self.input.east),\n                        float(self.input.north),\n                    ],\n                ],\n            }\n\n        except (TypeError, KeyError):\n            LOGGER.warning(\"Unable to convert bbox.\", exc_info=True)\n\n        return body\n</code></pre>"},{"location":"bbox/#extraction_methods.plugins.bbox.BboxInput","title":"<code>BboxInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for BBox Method Input.</p> <p>Parameters:</p> Name Type Description Default <code>west</code> <code>float | str</code> <p>west coordinate.</p> required <code>south</code> <code>float | str</code> <p>south coordinate.</p> required <code>east</code> <code>float | str</code> <p>east coordinate.</p> required <code>north</code> <code>float | str</code> <p>north coordinate.</p> required Source code in <code>extraction_methods/plugins/bbox.py</code> <pre><code>class BboxInput(Input):\n    \"\"\"\n    Model for BBox Method Input.\n    \"\"\"\n\n    west: float | str = Field(\n        description=\"west coordinate.\",\n    )\n    south: float | str = Field(\n        description=\"south coordinate.\",\n    )\n    east: float | str = Field(\n        description=\"east coordinate.\",\n    )\n    north: float | str = Field(\n        description=\"north coordinate.\",\n    )\n</code></pre>"},{"location":"ceda_observation/","title":"Ceda observation","text":""},{"location":"ceda_observation/#extraction_methods.plugins.ceda_observation.CEDAObservationExtract","title":"<code>CEDAObservationExtract</code>","text":"<p>               Bases: <code>ExtractionMethod</code></p> <p>Method name: <code>ceda_observation</code></p> <p>Returns a ceda observation record for the <code>input_term</code>.</p> Example Configuration <p>.. code-block:: yaml</p> <pre><code>- method: ceda_observation\n  inputs:\n    input_term: $url\n</code></pre> Source code in <code>extraction_methods/plugins/ceda_observation.py</code> <pre><code>class CEDAObservationExtract(ExtractionMethod):\n    \"\"\"\n    **Method name:** ``ceda_observation``\n\n    Returns a ceda observation record for the ``input_term``.\n\n    Example Configuration:\n        .. code-block:: yaml\n\n            - method: ceda_observation\n              inputs:\n                input_term: $url\n    \"\"\"\n\n    input_class = CEDAObservationInput\n\n    @update_input\n    def run(self, body: dict[str, Any]) -&gt; dict[str, Any]:\n        r = httpx.get(self.input.input_term, timeout=self.input.request_timeout)\n\n        if r.status_code == 200:\n            response = r.json()\n            record_type = response.get(\"record_type\")\n            url = response.get(\"url\")\n\n            if record_type == \"Dataset\" and url:\n                body[self.input.output_key] = url.split(\"/\")[-1]\n\n        return body\n</code></pre>"},{"location":"ceda_observation/#extraction_methods.plugins.ceda_observation.CEDAObservationInput","title":"<code>CEDAObservationInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for CEDA Observation Method Input.</p> <p>Parameters:</p> Name Type Description Default <code>input_term</code> <code>str</code> <p>term for method to run on.</p> <code>'$uri'</code> <code>request_timeout</code> <code>int</code> <p>request time out.</p> <code>15</code> <code>output_key</code> <code>str</code> <p>key to output to.</p> <code>'uuid'</code> Source code in <code>extraction_methods/plugins/ceda_observation.py</code> <pre><code>class CEDAObservationInput(Input):\n    \"\"\"\n    Model for CEDA Observation Method Input.\n    \"\"\"\n\n    input_term: str = Field(\n        default=\"$uri\",\n        description=\"term for method to run on.\",\n    )\n    request_timeout: int = Field(\n        default=15,\n        description=\"request time out.\",\n    )\n    output_key: str = Field(\n        default=\"uuid\",\n        description=\"key to output to.\",\n    )\n</code></pre>"},{"location":"ceda_vocabulary/","title":"Ceda vocabulary","text":""},{"location":"ceda_vocabulary/#extraction_methods.plugins.ceda_vocabulary.CEDAVocabularyExtract","title":"<code>CEDAVocabularyExtract</code>","text":"<p>               Bases: <code>ExtractionMethod</code></p> <p>Method name: <code>ceda_vocabulary</code></p> <p>Validates and sorts properties into vocabs and generates the <code>general</code> vocab for specified properties.</p> Example configuration <p>.. code-block:: yaml</p> <ul> <li>method: ceda_vocabulary   inputs:     url: vocab.ceda.ac.uk     namespace: cmip6     strict: False     terms:<ul> <li>start_time</li> <li>model</li> </ul> </li> </ul> Source code in <code>extraction_methods/plugins/ceda_vocabulary.py</code> <pre><code>class CEDAVocabularyExtract(ExtractionMethod):\n    \"\"\"\n    **Method name:** ``ceda_vocabulary``\n\n    Validates and sorts properties into vocabs and generates\n    the `general` vocab for specified properties.\n\n    Example configuration:\n        .. code-block:: yaml\n\n        - method: ceda_vocabulary\n          inputs:\n            url: vocab.ceda.ac.uk\n            namespace: cmip6\n            strict: False\n            terms:\n              - start_time\n              - model\n    \"\"\"\n\n    input_class = CEDAVocabularyInput\n\n    @update_input\n    def run(self, body: dict[str, Any]) -&gt; dict[str, Any]:\n\n        properties = body\n\n        if \"unspecified_vocab\" in body:\n            properties = body[\"unspecified_vocab\"]\n\n        req_data = {\n            \"namespace\": self.input.namespace,\n            \"terms\": self.input.terms,\n            \"properties\": properties,\n            \"strict\": self.input.strict,\n        }\n\n        response = httpx.post(\n            self.input.url,\n            json=req_data,\n            timeout=self.input.request_timeout,\n        )\n\n        if response.status_code != 200:\n            raise Exception(\n                f\"Bad response from vocab server: {response.status_code}, reason: {response.text}\"\n            )\n\n        json_response = response.json()\n\n        if json_response[\"error\"]:\n            raise Exception(f\"Vocab request failed, reason: {json_response['text']}\")\n\n        body = body | json_response[\"result\"]\n\n        if \"vocabs\" in body:\n            body[\"vocabs\"].append(self.input.namespace)\n\n        else:\n            body[\"vocabs\"] = self.input.namespace\n\n        return body\n</code></pre>"},{"location":"ceda_vocabulary/#extraction_methods.plugins.ceda_vocabulary.CEDAVocabularyInput","title":"<code>CEDAVocabularyInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for CEDA Vocab Method Input.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL of vocabulary server.</p> required <code>namespace</code> <code>str</code> <p>Namespace for vocab terms.</p> required <code>strict</code> <code>bool</code> <p>True if values should be validated.</p> <code>False</code> <code>terms</code> <code>list[str]</code> <p>terms to be validated.</p> <code>[]</code> <code>request_timeout</code> <code>int</code> <p>request time out.</p> <code>15</code> Source code in <code>extraction_methods/plugins/ceda_vocabulary.py</code> <pre><code>class CEDAVocabularyInput(Input):\n    \"\"\"\n    Model for CEDA Vocab Method Input.\n    \"\"\"\n\n    url: str = Field(\n        description=\"URL of vocabulary server.\",\n    )\n    namespace: str = Field(\n        description=\"Namespace for vocab terms.\",\n    )\n    strict: bool = Field(\n        default=False,\n        description=\"True if values should be validated.\",\n    )\n    terms: list[str] = Field(\n        default=[],\n        description=\"terms to be validated.\",\n    )\n    request_timeout: int = Field(\n        default=15,\n        description=\"request time out.\",\n    )\n</code></pre>"},{"location":"conditional/","title":"Conditional","text":""},{"location":"conditional/#extraction_methods.plugins.conditional.ConditionalExtract","title":"<code>ConditionalExtract</code>","text":"<p>               Bases: <code>ExtractionMethod</code></p> <p>Method name: <code>conditional</code></p> <p>Method to run set of extraction methods given a condition.</p> Example Configuration <p>.. code-block:: yaml</p> <pre><code>- method: conditional\n  inputs:\n    condition: $foo == bar\n    true_methods:\n      - method: default\n        inputs:\n          defaults:\n            hello: world\n    false_methods:\n      - method: default\n        inputs:\n          defaults:\n            hello: there\n</code></pre> Source code in <code>extraction_methods/plugins/conditional.py</code> <pre><code>class ConditionalExtract(ExtractionMethod):\n    \"\"\"\n    **Method name:** ``conditional``\n\n    Method to run set of extraction methods given a condition.\n\n    Example Configuration:\n        .. code-block:: yaml\n\n            - method: conditional\n              inputs:\n                condition: $foo == bar\n                true_methods:\n                  - method: default\n                    inputs:\n                      defaults:\n                        hello: world\n                false_methods:\n                  - method: default\n                    inputs:\n                      defaults:\n                        hello: there\n    \"\"\"\n\n    input_class = ConditionalInput\n\n    @update_input\n    def run(self, body: dict[str, Any]) -&gt; dict[str, Any]:\n\n        condition = \"\"\n        for term in self.input.condition.split(\" \"):\n\n            if term[0] == self.input.exists_key:\n                term = body.get(term[1:], None)\n\n                if isinstance(term, str):\n                    term = f\"'{term}'\"\n\n            condition += f\" {term}\"\n\n        extraction_methods = (\n            self.input.true_methods\n            if bool(eval(condition))  # nosec B307\n            else self.input.false_methods\n        )\n\n        for extraction_method in extraction_methods:\n            body = extraction_method._run(body)\n\n        return body\n</code></pre>"},{"location":"conditional/#extraction_methods.plugins.conditional.ConditionalInput","title":"<code>ConditionalInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for Conditional Method Input.</p> <p>Parameters:</p> Name Type Description Default <code>condition</code> <code>str</code> <p>Condition to decide on which methods are run.</p> required <code>true_methods</code> <code>list[ExtractionMethodConf]</code> <p>Extraction methods to run if contition is true.</p> <code>[]</code> <code>false_methods</code> <code>list[ExtractionMethodConf]</code> <p>Extraction methods to run if contition is false.</p> <code>[]</code> Source code in <code>extraction_methods/plugins/conditional.py</code> <pre><code>class ConditionalInput(Input):\n    \"\"\"\n    Model for Conditional Method Input.\n    \"\"\"\n\n    condition: str = Field(\n        description=\"Condition to decide on which methods are run.\",\n    )\n    true_methods: list[ExtractionMethodConf] = Field(\n        default=[],\n        description=\"Extraction methods to run if contition is true.\",\n    )\n    false_methods: list[ExtractionMethodConf] = Field(\n        default=[],\n        description=\"Extraction methods to run if contition is false.\",\n    )\n</code></pre>"},{"location":"controlled_vocabulary/","title":"Controlled vocabulary","text":""},{"location":"controlled_vocabulary/#extraction_methods.plugins.controlled_vocabulary.ControlledVocabularyExtract","title":"<code>ControlledVocabularyExtract</code>","text":"<p>               Bases: <code>ExtractionMethod</code></p> <p>Method name: <code>controlled_vocabulary</code></p> <p>Compare properties to a controlled vocabulary defined by a pydantic.BaseModel.</p> Example Configuration <p>.. code-block:: yaml</p> <pre><code>- name: controlled_vocabulary\n  inputs:\n    model: my_cv.collections.CMIP5\n    strict: False\n</code></pre> Source code in <code>extraction_methods/plugins/controlled_vocabulary.py</code> <pre><code>class ControlledVocabularyExtract(ExtractionMethod):\n    \"\"\"\n    **Method name:** ``controlled_vocabulary``\n\n    Compare properties to a controlled vocabulary defined by a pydantic.BaseModel.\n\n    Example Configuration:\n        .. code-block:: yaml\n\n            - name: controlled_vocabulary\n              inputs:\n                model: my_cv.collections.CMIP5\n                strict: False\n    \"\"\"\n\n    input_class = ControlledVocabularyInput\n\n    @update_input\n    def run(self, body: dict[str, Any]) -&gt; dict[str, Any]:\n        # Import data model\n        scopes = self.input.model.split(\".\")\n        module_str = \".\".join(scopes[:-1])\n\n        module = importlib.import_module(module_str)\n        klass = getattr(module, scopes[-1])\n\n        # Get metadata attributes\n        properties = body\n\n        # Instantiate data model\n        try:\n            cv = klass(**properties)\n            body = cv.dict()\n\n        except ValidationError as exc:\n            LOGGER.warning(exc)\n\n            if self.input.strict:\n                raise exc\n\n        return body\n</code></pre>"},{"location":"controlled_vocabulary/#extraction_methods.plugins.controlled_vocabulary.ControlledVocabularyInput","title":"<code>ControlledVocabularyInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for Contrilled Vocabulary Method Input.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str</code> <p>pydantic.BaseModel subclass to be imported at run-time, e.g. <code>package.module.class_name</code>.</p> required <code>strict</code> <code>bool</code> <p>If True, raise ValidationError, otherwise simply log ValidationError messages.</p> <code>False</code> Source code in <code>extraction_methods/plugins/controlled_vocabulary.py</code> <pre><code>class ControlledVocabularyInput(Input):\n    \"\"\"\n    Model for Contrilled Vocabulary Method Input.\n    \"\"\"\n\n    model: str = Field(\n        description=\"pydantic.BaseModel subclass to be imported at run-time, e.g. `package.module.class_name`.\",\n    )\n    strict: bool = Field(\n        default=False,\n        description=\"If True, raise ValidationError, otherwise simply log ValidationError messages.\",\n    )\n</code></pre>"},{"location":"datetime_bound_to_centroid/","title":"Datetime bound to centroid","text":""},{"location":"datetime_bound_to_centroid/#extraction_methods.plugins.datetime_bound_to_centroid.DatetimeBoundToCentroidExtract","title":"<code>DatetimeBoundToCentroidExtract</code>","text":"<p>               Bases: <code>ExtractionMethod</code></p> <p>Method name: <code>datetime_bound_to_centroid</code></p> <p>Accepts a dictionary of coordinate values and converts to <code>RFC 7946, section 5 &lt;https://tools.ietf.org/html/rfc7946#section-5&gt;</code>_ formatted bbox.</p> Example Configuration <p>.. code-block:: yaml</p> <pre><code>- method: datetime_bound_to_centroid\n  inputs:\n    start_datetime: $start_date\n    end_datetime: 2022-02-02\n    end_format: %Y-%m-%d\n    output_key: polygon\n</code></pre> Source code in <code>extraction_methods/plugins/datetime_bound_to_centroid.py</code> <pre><code>class DatetimeBoundToCentroidExtract(ExtractionMethod):\n    \"\"\"\n    **Method name:** ``datetime_bound_to_centroid``\n\n    Accepts a dictionary of coordinate values and converts to `RFC 7946, section 5 &lt;https://tools.ietf.org/html/rfc7946#section-5&gt;`_\n    formatted bbox.\n\n    Example Configuration:\n        .. code-block:: yaml\n\n            - method: datetime_bound_to_centroid\n              inputs:\n                start_datetime: $start_date\n                end_datetime: 2022-02-02\n                end_format: %Y-%m-%d\n                output_key: polygon\n    \"\"\"\n\n    input_class = DatetimeBoundToCentroidInput\n\n    def strip_time(self, datetime_str: str, datetime_format: str) -&gt; \"datetime\":\n        \"\"\"\n        strip datetime from value.\n\n        :param datetime_str: string to convert to datetime\n        :type datetime_str: str\n        :param datetime_format: format of datetime string\n        :type datetime_format: str\n\n        :return: datetime object\n        :rtype: datetime\n        \"\"\"\n        try:\n            return datetime.strptime(datetime_str, datetime_format)\n\n        except ValueError as v:\n            if len(v.args) &gt; 0 and v.args[0].startswith(\"unconverted data remains: \"):\n                datetime_str = datetime_str[: -(len(v.args[0]) - 26)]\n                return datetime.strptime(datetime_str, datetime_format)\n\n            raise v\n\n    @update_input\n    def run(self, body: dict[str, Any]) -&gt; dict[str, Any]:\n\n        start_datetime = self.strip_time(\n            self.input.start_datetime, self.input.start_format\n        )\n        end_datetime = self.strip_time(self.input.end_datetime, self.input.end_format)\n\n        centroid_datetime = start_datetime + (end_datetime - start_datetime) / 2\n\n        body[self.input.output_key] = centroid_datetime.strftime(\n            self.input.output_format\n        )\n\n        return body\n</code></pre>"},{"location":"datetime_bound_to_centroid/#extraction_methods.plugins.datetime_bound_to_centroid.DatetimeBoundToCentroidExtract.strip_time","title":"<code>strip_time(datetime_str, datetime_format)</code>","text":"<p>strip datetime from value.</p> <p>:param datetime_str: string to convert to datetime :type datetime_str: str :param datetime_format: format of datetime string :type datetime_format: str</p> <p>:return: datetime object :rtype: datetime</p> Source code in <code>extraction_methods/plugins/datetime_bound_to_centroid.py</code> <pre><code>def strip_time(self, datetime_str: str, datetime_format: str) -&gt; \"datetime\":\n    \"\"\"\n    strip datetime from value.\n\n    :param datetime_str: string to convert to datetime\n    :type datetime_str: str\n    :param datetime_format: format of datetime string\n    :type datetime_format: str\n\n    :return: datetime object\n    :rtype: datetime\n    \"\"\"\n    try:\n        return datetime.strptime(datetime_str, datetime_format)\n\n    except ValueError as v:\n        if len(v.args) &gt; 0 and v.args[0].startswith(\"unconverted data remains: \"):\n            datetime_str = datetime_str[: -(len(v.args[0]) - 26)]\n            return datetime.strptime(datetime_str, datetime_format)\n\n        raise v\n</code></pre>"},{"location":"datetime_bound_to_centroid/#extraction_methods.plugins.datetime_bound_to_centroid.DatetimeBoundToCentroidInput","title":"<code>DatetimeBoundToCentroidInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for Datetime Bound to Centroid Method Input.</p> <p>Parameters:</p> Name Type Description Default <code>start_datetime</code> <code>str</code> <p>Start datetime bound.</p> <code>'$start_datetime'</code> <code>start_format</code> <code>str</code> <p>Format for start datetime.</p> <code>'%Y-%m-%dT%H:%M:%S'</code> <code>end_datetime</code> <code>str</code> <p>End datetime bound.</p> <code>'$end_datetime'</code> <code>end_format</code> <code>str</code> <p>Format of end datetime.</p> <code>'%Y-%m-%dT%H:%M:%S'</code> <code>output_key</code> <code>str</code> <p>key to output to.</p> <code>'datetime'</code> <code>output_format</code> <code>str</code> <p>format of output.</p> <code>'%Y-%m-%dT%H:%M:%SZ'</code> Source code in <code>extraction_methods/plugins/datetime_bound_to_centroid.py</code> <pre><code>class DatetimeBoundToCentroidInput(Input):\n    \"\"\"\n    Model for Datetime Bound to Centroid Method Input.\n    \"\"\"\n\n    start_datetime: str = Field(\n        default=\"$start_datetime\",\n        description=\"Start datetime bound.\",\n    )\n    start_format: str = Field(\n        default=\"%Y-%m-%dT%H:%M:%S\",\n        description=\"Format for start datetime.\",\n    )\n    end_datetime: str = Field(\n        default=\"$end_datetime\",\n        description=\"End datetime bound.\",\n    )\n    end_format: str = Field(\n        default=\"%Y-%m-%dT%H:%M:%S\",\n        description=\"Format of end datetime.\",\n    )\n    output_key: str = Field(\n        default=\"datetime\",\n        description=\"key to output to.\",\n    )\n    output_format: str = Field(\n        default=\"%Y-%m-%dT%H:%M:%SZ\",\n        description=\"format of output.\",\n    )\n</code></pre>"},{"location":"default/","title":"Default","text":""},{"location":"default/#extraction_methods.plugins.default.DefaultExtract","title":"<code>DefaultExtract</code>","text":"<p>               Bases: <code>ExtractionMethod</code></p> <p>Method name: <code>default</code></p> <p>Takes a set of default facets.</p> Example configuration <p>.. code-block:: yaml</p> <pre><code>- method: default\n  inputs:\n    defaults:\n        mip_era: CMIP6\n</code></pre> Source code in <code>extraction_methods/plugins/default.py</code> <pre><code>class DefaultExtract(ExtractionMethod):\n    \"\"\"\n    **Method name:** ``default``\n\n    Takes a set of default facets.\n\n    Example configuration:\n        .. code-block:: yaml\n\n            - method: default\n              inputs:\n                defaults:\n                    mip_era: CMIP6\n    \"\"\"\n\n    input_class = DefaultInput\n\n    @update_input\n    def run(self, body: dict[str, Any]) -&gt; dict[str, Any]:\n\n        return body | self.input.defaults  # type: ignore[no-any-return]\n</code></pre>"},{"location":"default/#extraction_methods.plugins.default.DefaultInput","title":"<code>DefaultInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for Default Method Input.</p> <p>Parameters:</p> Name Type Description Default <code>defaults</code> <code>dict[str, Any]</code> <p>Defaults to be added.</p> required Source code in <code>extraction_methods/plugins/default.py</code> <pre><code>class DefaultInput(Input):\n    \"\"\"\n    Model for Default Method Input.\n    \"\"\"\n\n    defaults: dict[str, Any] = Field(\n        description=\"Defaults to be added.\",\n    )\n</code></pre>"},{"location":"dict_aggregator/","title":"Dict aggregator","text":""},{"location":"dict_aggregator/#extraction_methods.plugins.dict_aggregator.DictAggregatorExtract","title":"<code>DictAggregatorExtract</code>","text":"<p>               Bases: <code>ExtractionMethod</code></p> <p>Method name: <code>dict_aggregator</code></p> <p>Aggregate information within dictionary.</p> Example Configuration <p>.. code-block:: yaml</p> <pre><code>- method: dict_aggregator\n  inputs:\n    min:\n      - start_time\n    max:\n      - end_time\n    sum:\n      - size\n    list:\n      - term1\n      - term2\n</code></pre> Source code in <code>extraction_methods/plugins/dict_aggregator.py</code> <pre><code>class DictAggregatorExtract(ExtractionMethod):\n    \"\"\"\n    **Method name:** ``dict_aggregator``\n\n    Aggregate information within dictionary.\n\n    Example Configuration:\n        .. code-block:: yaml\n\n            - method: dict_aggregator\n              inputs:\n                min:\n                  - start_time\n                max:\n                  - end_time\n                sum:\n                  - size\n                list:\n                  - term1\n                  - term2\n    \"\"\"\n\n    input_class = DictAggregatorInput\n\n    @update_input\n    def run(self, body: dict[str, Any]) -&gt; dict[str, Any]:\n\n        for value in self.input.input_term.values():\n            for list_term in self.input.list_terms:\n                if list_term.key in value:\n                    body.setdefault(list_term.output_key, []).append(\n                        value[list_term.key]\n                    )\n\n            for sum_term in itertools.chain(\n                self.input.sum_terms, self.input.mean_terms\n            ):\n                if sum_term.key in value:\n                    body.setdefault(sum_term.output_key, 0)\n                    body[sum_term.output_key] += value[sum_term.key]\n\n            for min_term in self.input.min_terms:\n                if min_term.key in value and (\n                    min_term.output_key not in body\n                    or value[min_term.key] &lt; body[min_term.output_key]\n                ):\n                    body[min_term.output_key] = value[min_term.key]\n\n            for max_term in self.input.max_terms:\n                if max_term.key in value and (\n                    max_term.output_key not in body\n                    or value[max_term.key] &lt; body[max_term.output_key]\n                ):\n                    body[max_term.output_key] = value[max_term.key]\n\n        for mean_term in self.input.mean_terms:\n            body[mean_term.output_key] /= len(self.input.input_term)\n\n        return body\n</code></pre>"},{"location":"dict_aggregator/#extraction_methods.plugins.dict_aggregator.DictAggregatorInput","title":"<code>DictAggregatorInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for Dictionary Aggregator Method Input.</p> <p>Parameters:</p> Name Type Description Default <code>input_term</code> <code>str | dict[str, Any]</code> <p>term for method to run on.</p> <code>'$assets'</code> <code>min</code> <code>list[KeyOutputKey]</code> <p>list of terms for which the minimum of their aggregate should be returned.</p> <code>[]</code> <code>max</code> <code>list[KeyOutputKey]</code> <p>list of terms for which the maximum of their aggregate should be returned.</p> <code>[]</code> <code>sum</code> <code>list[KeyOutputKey]</code> <p>list of terms for which the sum of their aggregate should be returned.</p> <code>[]</code> <code>mean</code> <code>list[KeyOutputKey]</code> <p>list of terms for which the mean of their summed aggregate should be returned.</p> <code>[]</code> <code>bucket</code> <code>list[KeyOutputKey]</code> <p>list of terms for which the list of their aggregate should be returned.</p> <code>[]</code> Source code in <code>extraction_methods/plugins/dict_aggregator.py</code> <pre><code>class DictAggregatorInput(Input):\n    \"\"\"\n    Model for Dictionary Aggregator Method Input.\n    \"\"\"\n\n    input_term: str | dict[str, Any] = Field(\n        default=\"$assets\",\n        description=\"term for method to run on.\",\n    )\n    min: list[KeyOutputKey] = Field(\n        default=[],\n        description=\"list of terms for which the minimum of their aggregate should be returned.\",\n    )\n    max: list[KeyOutputKey] = Field(\n        default=[],\n        description=\"list of terms for which the maximum of their aggregate should be returned.\",\n    )\n    sum: list[KeyOutputKey] = Field(\n        default=[],\n        description=\"list of terms for which the sum of their aggregate should be returned.\",\n    )\n    mean: list[KeyOutputKey] = Field(\n        default=[],\n        description=\"list of terms for which the mean of their summed aggregate should be returned.\",\n    )\n    bucket: list[KeyOutputKey] = Field(\n        default=[],\n        description=\"list of terms for which the list of their aggregate should be returned.\",\n    )\n</code></pre>"},{"location":"elasticsearch_aggregation/","title":"Elasticsearch aggregation","text":""},{"location":"elasticsearch_aggregation/#extraction_methods.plugins.elasticsearch_aggregation.ElasticsearchAggregationExtract","title":"<code>ElasticsearchAggregationExtract</code>","text":"<p>               Bases: <code>ExtractionMethod</code></p> <p>Method name: <code>elasticsearch_aggregation</code></p> <p>Using an ID. Generate a summary of information for higher level entities.</p> Example Configuration <p>.. code-block:: yaml</p> <pre><code>- method: elasticsearch_aggregation\n  inputs:\n    index: ceda-index\n    id_term: item_id\n    client_kwargs:\n      hosts: ['host1:9200','host2:9200']\n    bbox:\n      - bbox\n    min:\n      - start_time\n    max:\n      - end_time\n    sum:\n      - size\n    list:\n      - term1\n      - term2\n</code></pre> Source code in <code>extraction_methods/plugins/elasticsearch_aggregation.py</code> <pre><code>class ElasticsearchAggregationExtract(ExtractionMethod):\n    \"\"\"\n    **Method name:** ``elasticsearch_aggregation``\n\n    Using an ID. Generate a summary of information for higher level entities.\n\n\n    Example Configuration:\n        .. code-block:: yaml\n\n            - method: elasticsearch_aggregation\n              inputs:\n                index: ceda-index\n                id_term: item_id\n                client_kwargs:\n                  hosts: ['host1:9200','host2:9200']\n                bbox:\n                  - bbox\n                min:\n                  - start_time\n                max:\n                  - end_time\n                sum:\n                  - size\n                list:\n                  - term1\n                  - term2\n    \"\"\"\n\n    def __init__(self, **kwargs: Any) -&gt; None:\n        super().__init__(**kwargs)\n        self.es = Elasticsearch(**self.input.client_kwargs)\n\n    @staticmethod\n    def basic_aggregation(agg_type: str, facet: KeyOutputKey) -&gt; dict[str, Any]:\n        \"\"\"\n        Query to retrieve the minimum value from docs.\n\n        :param agg_type: type of aggregation\n        :type agg_type: str\n        :param facet: facet to aggregate\n        :type facet: KeyOutputKey\n\n        :return: basic aggregation query\n        :rtype: dict\n        \"\"\"\n        return {facet.key: {agg_type: {\"field\": facet.key}}}\n\n    @staticmethod\n    def facet_composite_aggregation(facet: KeyOutputKey) -&gt; dict[str, Any]:\n        \"\"\"\n        Generate the composite aggregation for the facet.\n\n        :param facet: facet to aggregate\n        :type facet: KeyOutputKey\n\n        :return: composite aggregation query\n        :rtype: dict\n        \"\"\"\n        return {\n            facet.key: {\n                \"composite\": {\n                    \"sources\": [{facet.key: {\"terms\": {\"field\": facet.key}}}],\n                    \"size\": 100,\n                }\n            }\n        }\n\n    def extract_facet(self, aggregations: dict[str, Any], facet: KeyOutputKey) -&gt; Any:\n        \"\"\"\n        Function to extract the given facets from the aggregation.\n\n        :param input_dict: aggregations\n        :type input_dict: dict\n        :param facet: facet to be extracted\n        :type body: KeyOutputKey\n\n        :return: extracted facet\n        :rtype: Any\n        \"\"\"\n        if aggregation := aggregations.get(facet.key):\n\n            if facet_value := aggregation.get(\"value_as_string\"):\n                return facet_value\n\n            if facet_value := aggregation.get(\"bounds\"):\n                return facet_value\n\n            if facet_value := aggregation.get(\"value\"):\n                return facet_value\n\n    def extract_first_facet(\n        self, properties: dict[str, Any], facet: KeyOutputKey\n    ) -&gt; Any:\n        \"\"\"\n        Function to extract the given default facets from the first hit.\n\n        :param properties: properties from first record\n        :type properties: dict\n        :param facet: current facet to be extracted\n        :type KeyOutputKey: dict\n\n        :return: extracted facet\n        :rtype: Any\n        \"\"\"\n        if facet_value := properties.get(facet.key):\n            return facet_value\n\n    def extract_facet_lists(\n        self,\n        query: dict[str, Any],\n        aggregations: dict[str, Any],\n        facets: list[KeyOutputKey],\n    ) -&gt; dict[str, Any]:\n        \"\"\"\n        Function to extract the lists of given facets from the aggregation.\n\n        :param query: attribute dictionary to update\n        :type query: dict\n        :param aggregations: current generated properties\n        :type aggregations: dict\n        :param facets: facets to be extracted\n        :type facets: list\n\n        :return: extracted list facets\n        :rtype: dict\n        \"\"\"\n        output = defaultdict(list)\n        base_query = self.base_query()\n\n        while True:\n            next_query = self.base_query()\n            for facet in facets:\n                if aggregation := aggregations.get(facet.key):\n                    output[facet.output_key].extend(\n                        [bucket[\"key\"][facet.key] for bucket in aggregation[\"buckets\"]]\n                    )\n\n                    if hasattr(aggregation, \"after_key\"):\n                        next_query[\"aggs\"] |= query[\"aggs\"][facet.key]\n                        next_query[\"aggs\"][facet.key][\"composite\"][\"sources\"][\n                            \"after\"\n                        ] = {facet.key: aggregation[\"after_key\"][facet.key]}\n\n            if next_query == base_query:\n                break\n\n            result = self.es.search(index=self.input.index, body=next_query)\n            aggregations = result[\"aggregations\"]\n\n        return output\n\n    def base_query(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Base query to filter the results to a single collection.\n\n        :return: base query\n        :rtype: dict\n        \"\"\"\n        return {\n            \"query\": self.input.search_query,\n            \"aggs\": {},\n            \"size\": 1,\n        }\n\n    def construct_query(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Function to create the initial elasticsearch query.\n\n        :return: aggregation query\n        :rtype: dict\n        \"\"\"\n        query = self.base_query()\n\n        for bbox_term in self.input.bbox:\n            query[\"aggs\"].update(self.basic_aggregation(\"geo_bounds\", bbox_term))\n\n        for min_term in self.input.min:\n            query[\"aggs\"].update(self.basic_aggregation(\"min\", min_term))\n\n        for max_term in self.input.max:\n            query[\"aggs\"].update(self.basic_aggregation(\"max\", max_term))\n\n        for sum_term in self.input.sum:\n            query[\"aggs\"].update(self.basic_aggregation(\"sum\", sum_term))\n\n        for bucket_term in self.input.bucket:\n            query[\"aggs\"].update(self.facet_composite_aggregation(bucket_term))\n\n        return query\n\n    def extract_metadata(\n        self, query: dict[str, Any], result: dict[str, Any]\n    ) -&gt; dict[str, Any]:\n        \"\"\"\n        Function to extract the required metadata from the returned query result.\n\n        :param query: previous query\n        :type query: dict\n        :param result: resutls from previous query\n        :type result: dict\n\n        :return: metadata\n        :rtype: dict\n        \"\"\"\n        output = {}\n\n        properties = result[\"hits\"][\"hits\"][0][\"_source\"][\"properties\"]\n        aggregations = result[\"aggregations\"]\n\n        for facet in self.input.first:\n            if facet_value := self.extract_first_facet(properties, facet):\n                output[facet.output_key] = facet_value\n\n        for facet in (\n            self.input.geo_bounds + self.input.min + self.input.max + self.input.sum\n        ):\n            if facet_value := self.extract_facet(aggregations, facet):\n                output[facet.output_key] = facet_value\n\n        list_output = self.extract_facet_lists(query, aggregations, self.input.bucket)\n\n        output |= list_output\n\n        return output\n\n    def run(self, body: dict[str, Any]) -&gt; dict[str, Any]:\n\n        query = self.construct_query()\n\n        LOGGER.info(\"Querying Elasticsearch: %s\", query)\n\n        # Run query\n        result = self.es.search(\n            index=self.input.index, body=query, timeout=f\"{self.input.request_tiemout}s\"\n        )\n\n        # Extract metadata\n        output = self.extract_metadata(query, result)\n\n        return body | output\n</code></pre>"},{"location":"elasticsearch_aggregation/#extraction_methods.plugins.elasticsearch_aggregation.ElasticsearchAggregationExtract.base_query","title":"<code>base_query()</code>","text":"<p>Base query to filter the results to a single collection.</p> <p>:return: base query :rtype: dict</p> Source code in <code>extraction_methods/plugins/elasticsearch_aggregation.py</code> <pre><code>def base_query(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Base query to filter the results to a single collection.\n\n    :return: base query\n    :rtype: dict\n    \"\"\"\n    return {\n        \"query\": self.input.search_query,\n        \"aggs\": {},\n        \"size\": 1,\n    }\n</code></pre>"},{"location":"elasticsearch_aggregation/#extraction_methods.plugins.elasticsearch_aggregation.ElasticsearchAggregationExtract.basic_aggregation","title":"<code>basic_aggregation(agg_type, facet)</code>  <code>staticmethod</code>","text":"<p>Query to retrieve the minimum value from docs.</p> <p>:param agg_type: type of aggregation :type agg_type: str :param facet: facet to aggregate :type facet: KeyOutputKey</p> <p>:return: basic aggregation query :rtype: dict</p> Source code in <code>extraction_methods/plugins/elasticsearch_aggregation.py</code> <pre><code>@staticmethod\ndef basic_aggregation(agg_type: str, facet: KeyOutputKey) -&gt; dict[str, Any]:\n    \"\"\"\n    Query to retrieve the minimum value from docs.\n\n    :param agg_type: type of aggregation\n    :type agg_type: str\n    :param facet: facet to aggregate\n    :type facet: KeyOutputKey\n\n    :return: basic aggregation query\n    :rtype: dict\n    \"\"\"\n    return {facet.key: {agg_type: {\"field\": facet.key}}}\n</code></pre>"},{"location":"elasticsearch_aggregation/#extraction_methods.plugins.elasticsearch_aggregation.ElasticsearchAggregationExtract.construct_query","title":"<code>construct_query()</code>","text":"<p>Function to create the initial elasticsearch query.</p> <p>:return: aggregation query :rtype: dict</p> Source code in <code>extraction_methods/plugins/elasticsearch_aggregation.py</code> <pre><code>def construct_query(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Function to create the initial elasticsearch query.\n\n    :return: aggregation query\n    :rtype: dict\n    \"\"\"\n    query = self.base_query()\n\n    for bbox_term in self.input.bbox:\n        query[\"aggs\"].update(self.basic_aggregation(\"geo_bounds\", bbox_term))\n\n    for min_term in self.input.min:\n        query[\"aggs\"].update(self.basic_aggregation(\"min\", min_term))\n\n    for max_term in self.input.max:\n        query[\"aggs\"].update(self.basic_aggregation(\"max\", max_term))\n\n    for sum_term in self.input.sum:\n        query[\"aggs\"].update(self.basic_aggregation(\"sum\", sum_term))\n\n    for bucket_term in self.input.bucket:\n        query[\"aggs\"].update(self.facet_composite_aggregation(bucket_term))\n\n    return query\n</code></pre>"},{"location":"elasticsearch_aggregation/#extraction_methods.plugins.elasticsearch_aggregation.ElasticsearchAggregationExtract.extract_facet","title":"<code>extract_facet(aggregations, facet)</code>","text":"<p>Function to extract the given facets from the aggregation.</p> <p>:param input_dict: aggregations :type input_dict: dict :param facet: facet to be extracted :type body: KeyOutputKey</p> <p>:return: extracted facet :rtype: Any</p> Source code in <code>extraction_methods/plugins/elasticsearch_aggregation.py</code> <pre><code>def extract_facet(self, aggregations: dict[str, Any], facet: KeyOutputKey) -&gt; Any:\n    \"\"\"\n    Function to extract the given facets from the aggregation.\n\n    :param input_dict: aggregations\n    :type input_dict: dict\n    :param facet: facet to be extracted\n    :type body: KeyOutputKey\n\n    :return: extracted facet\n    :rtype: Any\n    \"\"\"\n    if aggregation := aggregations.get(facet.key):\n\n        if facet_value := aggregation.get(\"value_as_string\"):\n            return facet_value\n\n        if facet_value := aggregation.get(\"bounds\"):\n            return facet_value\n\n        if facet_value := aggregation.get(\"value\"):\n            return facet_value\n</code></pre>"},{"location":"elasticsearch_aggregation/#extraction_methods.plugins.elasticsearch_aggregation.ElasticsearchAggregationExtract.extract_facet_lists","title":"<code>extract_facet_lists(query, aggregations, facets)</code>","text":"<p>Function to extract the lists of given facets from the aggregation.</p> <p>:param query: attribute dictionary to update :type query: dict :param aggregations: current generated properties :type aggregations: dict :param facets: facets to be extracted :type facets: list</p> <p>:return: extracted list facets :rtype: dict</p> Source code in <code>extraction_methods/plugins/elasticsearch_aggregation.py</code> <pre><code>def extract_facet_lists(\n    self,\n    query: dict[str, Any],\n    aggregations: dict[str, Any],\n    facets: list[KeyOutputKey],\n) -&gt; dict[str, Any]:\n    \"\"\"\n    Function to extract the lists of given facets from the aggregation.\n\n    :param query: attribute dictionary to update\n    :type query: dict\n    :param aggregations: current generated properties\n    :type aggregations: dict\n    :param facets: facets to be extracted\n    :type facets: list\n\n    :return: extracted list facets\n    :rtype: dict\n    \"\"\"\n    output = defaultdict(list)\n    base_query = self.base_query()\n\n    while True:\n        next_query = self.base_query()\n        for facet in facets:\n            if aggregation := aggregations.get(facet.key):\n                output[facet.output_key].extend(\n                    [bucket[\"key\"][facet.key] for bucket in aggregation[\"buckets\"]]\n                )\n\n                if hasattr(aggregation, \"after_key\"):\n                    next_query[\"aggs\"] |= query[\"aggs\"][facet.key]\n                    next_query[\"aggs\"][facet.key][\"composite\"][\"sources\"][\n                        \"after\"\n                    ] = {facet.key: aggregation[\"after_key\"][facet.key]}\n\n        if next_query == base_query:\n            break\n\n        result = self.es.search(index=self.input.index, body=next_query)\n        aggregations = result[\"aggregations\"]\n\n    return output\n</code></pre>"},{"location":"elasticsearch_aggregation/#extraction_methods.plugins.elasticsearch_aggregation.ElasticsearchAggregationExtract.extract_first_facet","title":"<code>extract_first_facet(properties, facet)</code>","text":"<p>Function to extract the given default facets from the first hit.</p> <p>:param properties: properties from first record :type properties: dict :param facet: current facet to be extracted :type KeyOutputKey: dict</p> <p>:return: extracted facet :rtype: Any</p> Source code in <code>extraction_methods/plugins/elasticsearch_aggregation.py</code> <pre><code>def extract_first_facet(\n    self, properties: dict[str, Any], facet: KeyOutputKey\n) -&gt; Any:\n    \"\"\"\n    Function to extract the given default facets from the first hit.\n\n    :param properties: properties from first record\n    :type properties: dict\n    :param facet: current facet to be extracted\n    :type KeyOutputKey: dict\n\n    :return: extracted facet\n    :rtype: Any\n    \"\"\"\n    if facet_value := properties.get(facet.key):\n        return facet_value\n</code></pre>"},{"location":"elasticsearch_aggregation/#extraction_methods.plugins.elasticsearch_aggregation.ElasticsearchAggregationExtract.extract_metadata","title":"<code>extract_metadata(query, result)</code>","text":"<p>Function to extract the required metadata from the returned query result.</p> <p>:param query: previous query :type query: dict :param result: resutls from previous query :type result: dict</p> <p>:return: metadata :rtype: dict</p> Source code in <code>extraction_methods/plugins/elasticsearch_aggregation.py</code> <pre><code>def extract_metadata(\n    self, query: dict[str, Any], result: dict[str, Any]\n) -&gt; dict[str, Any]:\n    \"\"\"\n    Function to extract the required metadata from the returned query result.\n\n    :param query: previous query\n    :type query: dict\n    :param result: resutls from previous query\n    :type result: dict\n\n    :return: metadata\n    :rtype: dict\n    \"\"\"\n    output = {}\n\n    properties = result[\"hits\"][\"hits\"][0][\"_source\"][\"properties\"]\n    aggregations = result[\"aggregations\"]\n\n    for facet in self.input.first:\n        if facet_value := self.extract_first_facet(properties, facet):\n            output[facet.output_key] = facet_value\n\n    for facet in (\n        self.input.geo_bounds + self.input.min + self.input.max + self.input.sum\n    ):\n        if facet_value := self.extract_facet(aggregations, facet):\n            output[facet.output_key] = facet_value\n\n    list_output = self.extract_facet_lists(query, aggregations, self.input.bucket)\n\n    output |= list_output\n\n    return output\n</code></pre>"},{"location":"elasticsearch_aggregation/#extraction_methods.plugins.elasticsearch_aggregation.ElasticsearchAggregationExtract.facet_composite_aggregation","title":"<code>facet_composite_aggregation(facet)</code>  <code>staticmethod</code>","text":"<p>Generate the composite aggregation for the facet.</p> <p>:param facet: facet to aggregate :type facet: KeyOutputKey</p> <p>:return: composite aggregation query :rtype: dict</p> Source code in <code>extraction_methods/plugins/elasticsearch_aggregation.py</code> <pre><code>@staticmethod\ndef facet_composite_aggregation(facet: KeyOutputKey) -&gt; dict[str, Any]:\n    \"\"\"\n    Generate the composite aggregation for the facet.\n\n    :param facet: facet to aggregate\n    :type facet: KeyOutputKey\n\n    :return: composite aggregation query\n    :rtype: dict\n    \"\"\"\n    return {\n        facet.key: {\n            \"composite\": {\n                \"sources\": [{facet.key: {\"terms\": {\"field\": facet.key}}}],\n                \"size\": 100,\n            }\n        }\n    }\n</code></pre>"},{"location":"elasticsearch_aggregation/#extraction_methods.plugins.elasticsearch_aggregation.ElasticsearchAggregationInput","title":"<code>ElasticsearchAggregationInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for Elasticsearch Aggregation Input.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>str</code> <p>Name of the index holding the STAC entities.</p> required <code>id_term</code> <code>str</code> <p>Term used for agregating the STAC entities.</p> required <code>client_kwargs</code> <code>dict[str, Any]</code> <p>Parameters passed to elasticsearch client.</p> <code>{}</code> <code>search_query</code> <code>dict[str, Any]</code> <p>Session parameters passed to elasticsearch client.</p> <code>{'bool': {'must_not': [{'term': {'categories.keyword': {'value': 'hidden'}}}], 'must': [{'term': {'path': {'value': '$uri'}}}]}}</code> <code>geo_bound</code> <code>list[KeyOutputKey]</code> <p>list of terms for which the minimum of their aggregate should be returned.</p> <code>[]</code> <code>first</code> <code>list[KeyOutputKey]</code> <p>list of terms for which the first record's value should be returned.</p> <code>[]</code> <code>min</code> <code>list[KeyOutputKey]</code> <p>list of terms for which the minimum of their aggregate should be returned.</p> <code>[]</code> <code>max</code> <code>list[KeyOutputKey]</code> <p>list of terms for which the maximum of their aggregate should be returned.</p> <code>[]</code> <code>sum</code> <code>list[KeyOutputKey]</code> <p>list of terms for which the sum of their aggregate should be returned.</p> <code>[]</code> <code>mean</code> <code>list[KeyOutputKey]</code> <p>list of terms for which the mean of their summed aggregate should be returned.</p> <code>[]</code> <code>bucket</code> <code>list[KeyOutputKey]</code> <p>list of terms for which the list of their aggregate should be returned.</p> <code>[]</code> <code>request_tiemout</code> <code>int</code> <p>Time out for search.</p> <code>15</code> <code>allow_multiple</code> <code>bool</code> <p>True if multiple labels are allowed.</p> <code>True</code> <code>output_key</code> <code>str</code> <p>key to output to.</p> <code>'label'</code> Source code in <code>extraction_methods/plugins/elasticsearch_aggregation.py</code> <pre><code>class ElasticsearchAggregationInput(Input):\n    \"\"\"\n    Model for Elasticsearch Aggregation Input.\n    \"\"\"\n\n    index: str = Field(\n        description=\"Name of the index holding the STAC entities.\",\n    )\n    id_term: str = Field(\n        description=\"Term used for agregating the STAC entities.\",\n    )\n    client_kwargs: dict[str, Any] = Field(\n        default={},\n        description=\"Parameters passed to elasticsearch client.\",\n    )\n    search_query: dict[str, Any] = Field(\n        default={\n            \"bool\": {\n                \"must_not\": [{\"term\": {\"categories.keyword\": {\"value\": \"hidden\"}}}],\n                \"must\": [{\"term\": {\"path\": {\"value\": \"$uri\"}}}],\n            }\n        },\n        description=\"Session parameters passed to elasticsearch client.\",\n    )\n    geo_bound: list[KeyOutputKey] = Field(\n        default=[],\n        description=\"list of terms for which the minimum of their aggregate should be returned.\",\n    )\n    first: list[KeyOutputKey] = Field(\n        default=[],\n        description=\"list of terms for which the first record's value should be returned.\",\n    )\n    min: list[KeyOutputKey] = Field(\n        default=[],\n        description=\"list of terms for which the minimum of their aggregate should be returned.\",\n    )\n    max: list[KeyOutputKey] = Field(\n        default=[],\n        description=\"list of terms for which the maximum of their aggregate should be returned.\",\n    )\n    sum: list[KeyOutputKey] = Field(\n        default=[],\n        description=\"list of terms for which the sum of their aggregate should be returned.\",\n    )\n    mean: list[KeyOutputKey] = Field(\n        default=[],\n        description=\"list of terms for which the mean of their summed aggregate should be returned.\",\n    )\n    bucket: list[KeyOutputKey] = Field(\n        default=[],\n        description=\"list of terms for which the list of their aggregate should be returned.\",\n    )\n    request_tiemout: int = Field(\n        default=15,\n        description=\"Time out for search.\",\n    )\n    allow_multiple: bool = Field(\n        default=True,\n        description=\"True if multiple labels are allowed.\",\n    )\n    output_key: str = Field(\n        default=\"label\",\n        description=\"key to output to.\",\n    )\n</code></pre>"},{"location":"elasticsearch_search/","title":"Elasticsearch search","text":""},{"location":"elasticsearch_search/#extraction_methods.plugins.elasticsearch_search.ElasticsearchSearchExtract","title":"<code>ElasticsearchSearchExtract</code>","text":"<p>               Bases: <code>ExtractionMethod</code></p> <p>Method name: <code>elasticsearch_search</code></p> <p>Search Elasticsearch.</p> Example Configuration <p>.. code-block:: yaml</p> <pre><code>- method: elasticsearch\n  inputs:\n    index: ceda-index\n    client_kwargs:\n      hosts: ['host1:9200','host2:9200']\n    search_kwargs:\n      timeout: 100s\n    body:\n      query:\n        regex: $regex_value\n      _source:\n        - path\n</code></pre> Source code in <code>extraction_methods/plugins/elasticsearch_search.py</code> <pre><code>class ElasticsearchSearchExtract(ExtractionMethod):\n    \"\"\"\n    **Method name:** ``elasticsearch_search``\n\n    Search Elasticsearch.\n\n\n    Example Configuration:\n        .. code-block:: yaml\n\n            - method: elasticsearch\n              inputs:\n                index: ceda-index\n                client_kwargs:\n                  hosts: ['host1:9200','host2:9200']\n                search_kwargs:\n                  timeout: 100s\n                body:\n                  query:\n                    regex: $regex_value\n                  _source:\n                    - path\n    \"\"\"\n\n    input_class = ElasticsearchSearchInput\n\n    @update_input\n    def run(self, body: dict[str, Any]) -&gt; dict[str, Any]:\n\n        es = Elasticsearch_client(**self.input.client_kwargs)\n\n        # Run search\n        result = es.search(\n            index=self.input.index, body=self.input.body, **self.input.search_kwargs\n        )\n\n        body[self.input.output_key] = result[\"hits\"][\"hits\"]\n\n        return body\n</code></pre>"},{"location":"elasticsearch_search/#extraction_methods.plugins.elasticsearch_search.ElasticsearchSearchInput","title":"<code>ElasticsearchSearchInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for Elasticsearch Assets Backend Input.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>str</code> <p>Index to search on.</p> required <code>client_kwargs</code> <code>dict[str, Any]</code> <p>Client kwargs.</p> <code>{}</code> <code>search_kwargs</code> <code>dict[str, Any]</code> <p>Search kwargs.</p> <code>{'timeout': '60s'}</code> <code>body</code> <code>dict[str, Any]</code> <p>Body of search request.</p> required <code>output_key</code> <code>str</code> <p>key to output to.</p> <code>'es_result'</code> Source code in <code>extraction_methods/plugins/elasticsearch_search.py</code> <pre><code>class ElasticsearchSearchInput(Input):\n    \"\"\"\n    Model for Elasticsearch Assets Backend Input.\n    \"\"\"\n\n    index: str = Field(\n        description=\"Index to search on.\",\n    )\n    client_kwargs: dict[str, Any] = Field(\n        default={},\n        description=\"Client kwargs.\",\n    )\n    search_kwargs: dict[str, Any] = Field(\n        default={\"timeout\": \"60s\"},\n        description=\"Search kwargs.\",\n    )\n    body: dict[str, Any] = Field(\n        description=\"Body of search request.\",\n    )\n    output_key: str = Field(\n        default=\"es_result\",\n        description=\"key to output to.\",\n    )\n</code></pre>"},{"location":"facet_map/","title":"Facet map","text":""},{"location":"facet_map/#extraction_methods.plugins.facet_map.FacetMapExtract","title":"<code>FacetMapExtract</code>","text":"<p>               Bases: <code>ExtractionMethod</code></p> <p>Method name: <code>facet_map</code></p> <p>In some cases, you may wish to map the header attributes to different facets. This method takes a map and converts the facet labels into those specified.</p> Example Configuration <p>.. code-block:: yaml</p> <pre><code>- method: facet_map\n  inputs:\n    term_map:\n        old_key: new_key\n        time_coverage_start: start_time\n</code></pre> Source code in <code>extraction_methods/plugins/facet_map.py</code> <pre><code>class FacetMapExtract(ExtractionMethod):\n    \"\"\"\n    **Method name:** ``facet_map``\n\n    In some cases, you may wish to map the header attributes to different\n    facets. This method takes a map and converts the facet labels into those\n    specified.\n\n    Example Configuration:\n        .. code-block:: yaml\n\n            - method: facet_map\n              inputs:\n                term_map:\n                    old_key: new_key\n                    time_coverage_start: start_time\n    \"\"\"\n\n    input_class = FacetMapInput\n\n    @update_input\n    def run(self, body: dict[str, Any]) -&gt; dict[str, Any]:\n\n        for old_key, new_key in self.input.term_map:\n            try:\n                value = body.pop(old_key)\n                body[new_key] = value\n\n            except KeyError:\n                pass\n\n        return body\n</code></pre>"},{"location":"facet_map/#extraction_methods.plugins.facet_map.FacetMapInput","title":"<code>FacetMapInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for Facet Map Input.</p> <p>Parameters:</p> Name Type Description Default <code>term_map</code> <code>dict[str, str]</code> <p>Dictionary of terms to be mapped.</p> <code>{}</code> Source code in <code>extraction_methods/plugins/facet_map.py</code> <pre><code>class FacetMapInput(Input):\n    \"\"\"\n    Model for Facet Map Input.\n    \"\"\"\n\n    term_map: dict[str, str] = Field(\n        default={},\n        description=\"Dictionary of terms to be mapped.\",\n    )\n</code></pre>"},{"location":"facet_prefix/","title":"Facet prefix","text":""},{"location":"facet_prefix/#extraction_methods.plugins.facet_prefix.FacetPrefixExtract","title":"<code>FacetPrefixExtract</code>","text":"<p>               Bases: <code>ExtractionMethod</code></p> <p>Method name: <code>facet_prefix</code></p> <p>In some cases, you may wish add a prefix to some or all of the facets based on the vocabulary they're from.</p> Example Configuration <p>.. code-block:: yaml</p> <pre><code>- method: facet_prefix\n  inputs:\n    prefix: cmip6\n    keys:\n    - start_time\n    - model\n</code></pre> Source code in <code>extraction_methods/plugins/facet_prefix.py</code> <pre><code>class FacetPrefixExtract(ExtractionMethod):\n    \"\"\"\n    **Method name:** ``facet_prefix``\n\n    In some cases, you may wish add a prefix to some or all of the facets\n    based on the vocabulary they're from.\n\n    Example Configuration:\n        .. code-block:: yaml\n\n            - method: facet_prefix\n              inputs:\n                prefix: cmip6\n                keys:\n                - start_time\n                - model\n    \"\"\"\n\n    input_class = FacetPrefixInput\n\n    @update_input\n    def run(self, body: dict[str, Any]) -&gt; dict[str, Any]:\n\n        for term in self.input.keys:\n            try:\n                value = body.pop(term)\n                body[f\"{self.input.prefix}:{term}\"] = value\n\n            except KeyError:\n                pass\n\n        return body\n</code></pre>"},{"location":"facet_prefix/#extraction_methods.plugins.facet_prefix.FacetPrefixInput","title":"<code>FacetPrefixInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for Facet Prefix Input.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>Prefix to be added.</p> required <code>keys</code> <code>list[str]</code> <p>list of keys that require prefix.</p> required Source code in <code>extraction_methods/plugins/facet_prefix.py</code> <pre><code>class FacetPrefixInput(Input):\n    \"\"\"\n    Model for Facet Prefix Input.\n    \"\"\"\n\n    prefix: str = Field(\n        description=\"Prefix to be added.\",\n    )\n    keys: list[str] = Field(\n        description=\"list of keys that require prefix.\",\n    )\n</code></pre>"},{"location":"general_function/","title":"General function","text":""},{"location":"general_function/#extraction_methods.plugins.general_function.Function","title":"<code>Function</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for Fuction.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of function.</p> required <code>args</code> <code>list[Any]</code> <p>list of arguments for function.</p> <code>[]</code> <code>kwargs</code> <code>dict[str, Any]</code> <p>dictionary of key word arguments for function.</p> <code>{}</code> Source code in <code>extraction_methods/plugins/general_function.py</code> <pre><code>class Function(BaseModel):  # type: ignore[no-redef]\n    \"\"\"\n    Model for Fuction.\n    \"\"\"\n\n    name: str = Field(\n        description=\"Name of function.\",\n    )\n    args: list[Any] = Field(\n        default=[],\n        description=\"list of arguments for function.\",\n    )\n    kwargs: dict[str, Any] = Field(\n        default={},\n        description=\"dictionary of key word arguments for function.\",\n    )\n</code></pre>"},{"location":"general_function/#extraction_methods.plugins.general_function.GeneralFunctionExtract","title":"<code>GeneralFunctionExtract</code>","text":"<p>               Bases: <code>ExtractionMethod</code></p> <p>Method name: <code>general_function</code></p> <p>Accepts a dictionary. String values are popped from the dictionary and are put back into the dictionary with the <code>key</code> specified.</p> Example Configuration <p>.. code-block:: yaml</p> <pre><code>- method: general_function\n  inputs:\n    funtion:\n      name: import.path.to.the.fuction\n      args:\n        - hello\n        - world\n      kwargs:\n        hello: world\n        foo: bar\n</code></pre> Source code in <code>extraction_methods/plugins/general_function.py</code> <pre><code>class GeneralFunctionExtract(ExtractionMethod):\n    \"\"\"\n    **Method name:** ``general_function``\n\n    Accepts a dictionary. String values are popped from the dictionary and\n    are put back into the dictionary with the ``key`` specified.\n\n    Example Configuration:\n        .. code-block:: yaml\n\n            - method: general_function\n              inputs:\n                funtion:\n                  name: import.path.to.the.fuction\n                  args:\n                    - hello\n                    - world\n                  kwargs:\n                    hello: world\n                    foo: bar\n    \"\"\"\n\n    input_class = GeneralFunctionInput\n\n    @update_input\n    def run(self, body: dict[str, Any]) -&gt; dict[str, Any]:\n        output_body = body.copy()\n\n        module_name, function_name = self.input.function.name.rsplit(\n            self.input.delimiter, 1\n        )\n\n        module = importlib.import_module(module_name)\n\n        function = getattr(module, function_name)\n\n        result = function(*self.input.function.args, **self.input.function.kwargs)\n\n        if self.input.output_key:\n            output_body[self.input.output_key] = result\n\n        elif isinstance(result, dict):\n            output_body |= result\n\n        return output_body\n</code></pre>"},{"location":"general_function/#extraction_methods.plugins.general_function.GeneralFunctionInput","title":"<code>GeneralFunctionInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for General Fuction Input.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Function</code> <p>Function to be run name maybe seperatated my delimieter.</p> required <code>delimiter</code> <code>str</code> <p>text delimiter to put between module/function names.</p> <code>'.'</code> <code>output_key</code> <code>str</code> <p>key to output to, else response will be merged with body.</p> <code>''</code> Source code in <code>extraction_methods/plugins/general_function.py</code> <pre><code>class GeneralFunctionInput(Input):\n    \"\"\"\n    Model for General Fuction Input.\n    \"\"\"\n\n    function: Function = Field(\n        description=\"Function to be run name maybe seperatated my delimieter.\",\n    )\n    delimiter: str = Field(\n        default=\".\",\n        description=\"text delimiter to put between module/function names.\",\n    )\n    output_key: str = Field(\n        default=\"\",\n        description=\"key to output to, else response will be merged with body.\",\n    )\n</code></pre>"},{"location":"geometry/","title":"Geometry","text":""},{"location":"geometry/#extraction_methods.plugins.geometry.GeometryExtract","title":"<code>GeometryExtract</code>","text":"<p>               Bases: <code>ExtractionMethod</code></p> <p>Method name: <code>geometry</code></p> <p>Accepts a dictionary of coordinate values and converts to <code>RFC 7946, &lt;https://tools.ietf.org/html/rfc7946&gt;</code>_ formatted geometry.</p> Example Configuration <p>.. code-block:: yaml</p> <pre><code>- method: geometry\n  inputs:\n    type: line\n    coordinates:\n      -\n        - 0\n        - 0\n      -\n        - $lon_2\n        - $lat_2\n</code></pre> Source code in <code>extraction_methods/plugins/geometry.py</code> <pre><code>class GeometryExtract(ExtractionMethod):\n    \"\"\"\n    **Method name:** ``geometry``\n\n    Accepts a dictionary of coordinate values and converts to `RFC 7946, &lt;https://tools.ietf.org/html/rfc7946&gt;`_\n    formatted geometry.\n\n    Example Configuration:\n        .. code-block:: yaml\n\n            - method: geometry\n              inputs:\n                type: line\n                coordinates:\n                  -\n                    - 0\n                    - 0\n                  -\n                    - $lon_2\n                    - $lat_2\n    \"\"\"\n\n    input_class = GeometryInput\n\n    def point(self, coordinates: list[str | float]) -&gt; list[float]:\n        \"\"\"\n        Get point coordinates\n\n        :param coordinates: list of coordinates\n        :type coordinates: list\n\n        :return: coordinates\n        :rtype: list\n        \"\"\"\n\n        return [\n            float(coordinates[0]),\n            float(coordinates[1]),\n        ]\n\n    def line(self, coordinates: list[list[str | float]]) -&gt; list[list[float]]:\n        \"\"\"\n        Get line coordinates\n\n        :param coordinates: list of coordinates\n        :type coordinates: list\n\n        :return: coordinates\n        :rtype: list\n        \"\"\"\n\n        return [self.point(coordinate) for coordinate in coordinates]\n\n    def polygon(self, coordinates: list[list[str | float]]) -&gt; list[list[list[float]]]:\n        \"\"\"\n        Get polygon coordinates\n\n        :param coordinates: list of coordinates\n        :type coordinates: list\n\n        :return: coordinates\n        :rtype: list\n        \"\"\"\n\n        output = self.line(coordinates)\n\n        if output[0] != output[-1]:\n            # Add the first point to the end to complete the shape\n            output.append(output[0])\n\n        return [output]\n\n    def multi(self, coordinate_type: str, coordinates: list[Any]) -&gt; list[Any]:\n        \"\"\"\n        Get polygon coordinates\n\n        :param coordinate_type: type of coordinates\n        :type coordinate_type: str\n        :param coordinates: list of coordinates\n        :type coordinates: list\n\n        :return: coordinates\n        :rtype: list\n        \"\"\"\n\n        return [\n            self.get_coordinates(coordinate_type.lstrip(\"Multi\"), coordinate)\n            for coordinate in coordinates\n        ]\n\n    def get_coordinates(\n        self, coordinate_type: str, coordinates: list[Any]\n    ) -&gt; list[Any]:\n        \"\"\"\n        Get coordinates\n\n        :param coordinate_type: type of coordinates\n        :type coordinate_type: str\n        :param coordinates: list of coordinates\n        :type coordinates: list\n\n        :return: coordinates\n        :rtype: list\n        \"\"\"\n\n        if coordinate_type == \"Point\":\n            return self.point(coordinates)\n\n        if coordinate_type == \"Line\":\n            return self.line(coordinates)\n\n        if coordinate_type == \"Polygon\":\n            return self.polygon(coordinates)\n\n        if coordinate_type.startswith(\"Multi\"):\n            return self.multi(coordinate_type, coordinates)\n\n        return []\n\n    @update_input\n    def run(self, body: dict[str, Any]) -&gt; dict[str, Any]:\n\n        try:\n            body[self.input.output_key] = {\n                \"type\": self.input.type,\n                \"coordinates\": self.get_coordinates(\n                    self.input.type,\n                    self.input.coordinates,\n                ),\n            }\n\n        except KeyError:\n            LOGGER.warning(\n                \"Unable to convert to a line geometry.\",\n                exc_info=True,\n            )\n\n        return body\n</code></pre>"},{"location":"geometry/#extraction_methods.plugins.geometry.GeometryExtract.get_coordinates","title":"<code>get_coordinates(coordinate_type, coordinates)</code>","text":"<p>Get coordinates</p> <p>:param coordinate_type: type of coordinates :type coordinate_type: str :param coordinates: list of coordinates :type coordinates: list</p> <p>:return: coordinates :rtype: list</p> Source code in <code>extraction_methods/plugins/geometry.py</code> <pre><code>def get_coordinates(\n    self, coordinate_type: str, coordinates: list[Any]\n) -&gt; list[Any]:\n    \"\"\"\n    Get coordinates\n\n    :param coordinate_type: type of coordinates\n    :type coordinate_type: str\n    :param coordinates: list of coordinates\n    :type coordinates: list\n\n    :return: coordinates\n    :rtype: list\n    \"\"\"\n\n    if coordinate_type == \"Point\":\n        return self.point(coordinates)\n\n    if coordinate_type == \"Line\":\n        return self.line(coordinates)\n\n    if coordinate_type == \"Polygon\":\n        return self.polygon(coordinates)\n\n    if coordinate_type.startswith(\"Multi\"):\n        return self.multi(coordinate_type, coordinates)\n\n    return []\n</code></pre>"},{"location":"geometry/#extraction_methods.plugins.geometry.GeometryExtract.line","title":"<code>line(coordinates)</code>","text":"<p>Get line coordinates</p> <p>:param coordinates: list of coordinates :type coordinates: list</p> <p>:return: coordinates :rtype: list</p> Source code in <code>extraction_methods/plugins/geometry.py</code> <pre><code>def line(self, coordinates: list[list[str | float]]) -&gt; list[list[float]]:\n    \"\"\"\n    Get line coordinates\n\n    :param coordinates: list of coordinates\n    :type coordinates: list\n\n    :return: coordinates\n    :rtype: list\n    \"\"\"\n\n    return [self.point(coordinate) for coordinate in coordinates]\n</code></pre>"},{"location":"geometry/#extraction_methods.plugins.geometry.GeometryExtract.multi","title":"<code>multi(coordinate_type, coordinates)</code>","text":"<p>Get polygon coordinates</p> <p>:param coordinate_type: type of coordinates :type coordinate_type: str :param coordinates: list of coordinates :type coordinates: list</p> <p>:return: coordinates :rtype: list</p> Source code in <code>extraction_methods/plugins/geometry.py</code> <pre><code>def multi(self, coordinate_type: str, coordinates: list[Any]) -&gt; list[Any]:\n    \"\"\"\n    Get polygon coordinates\n\n    :param coordinate_type: type of coordinates\n    :type coordinate_type: str\n    :param coordinates: list of coordinates\n    :type coordinates: list\n\n    :return: coordinates\n    :rtype: list\n    \"\"\"\n\n    return [\n        self.get_coordinates(coordinate_type.lstrip(\"Multi\"), coordinate)\n        for coordinate in coordinates\n    ]\n</code></pre>"},{"location":"geometry/#extraction_methods.plugins.geometry.GeometryExtract.point","title":"<code>point(coordinates)</code>","text":"<p>Get point coordinates</p> <p>:param coordinates: list of coordinates :type coordinates: list</p> <p>:return: coordinates :rtype: list</p> Source code in <code>extraction_methods/plugins/geometry.py</code> <pre><code>def point(self, coordinates: list[str | float]) -&gt; list[float]:\n    \"\"\"\n    Get point coordinates\n\n    :param coordinates: list of coordinates\n    :type coordinates: list\n\n    :return: coordinates\n    :rtype: list\n    \"\"\"\n\n    return [\n        float(coordinates[0]),\n        float(coordinates[1]),\n    ]\n</code></pre>"},{"location":"geometry/#extraction_methods.plugins.geometry.GeometryExtract.polygon","title":"<code>polygon(coordinates)</code>","text":"<p>Get polygon coordinates</p> <p>:param coordinates: list of coordinates :type coordinates: list</p> <p>:return: coordinates :rtype: list</p> Source code in <code>extraction_methods/plugins/geometry.py</code> <pre><code>def polygon(self, coordinates: list[list[str | float]]) -&gt; list[list[list[float]]]:\n    \"\"\"\n    Get polygon coordinates\n\n    :param coordinates: list of coordinates\n    :type coordinates: list\n\n    :return: coordinates\n    :rtype: list\n    \"\"\"\n\n    output = self.line(coordinates)\n\n    if output[0] != output[-1]:\n        # Add the first point to the end to complete the shape\n        output.append(output[0])\n\n    return [output]\n</code></pre>"},{"location":"geometry/#extraction_methods.plugins.geometry.GeometryInput","title":"<code>GeometryInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for Geometry Input.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>Literal['Point', 'LineString', 'Polygon', 'MultiPointString', 'MultiLineString', 'MultiPolygon']</code> <p>Type of geometry to be produced.</p> required <code>coordinates</code> <code>list[Any]</code> <p>list of coordinates to convert to geometry. Ordering is respected.</p> required <code>output_key</code> <code>str</code> <p>key to output to.</p> <code>'geometry'</code> Source code in <code>extraction_methods/plugins/geometry.py</code> <pre><code>class GeometryInput(Input):\n    \"\"\"\n    Model for Geometry Input.\n    \"\"\"\n\n    type: Literal[\n        \"Point\",\n        \"LineString\",\n        \"Polygon\",\n        \"MultiPointString\",\n        \"MultiLineString\",\n        \"MultiPolygon\",\n    ] = Field(\n        description=\"Type of geometry to be produced.\",\n    )\n    coordinates: list[Any] = Field(\n        description=\"list of coordinates to convert to geometry. Ordering is respected.\",\n    )\n    output_key: str = Field(\n        default=\"geometry\",\n        description=\"key to output to.\",\n    )\n</code></pre>"},{"location":"geometry_to_bbox/","title":"Geometry to bbox","text":""},{"location":"geometry_to_bbox/#extraction_methods.plugins.geometry_to_bbox.GeometryToBboxExtract","title":"<code>GeometryToBboxExtract</code>","text":"<p>               Bases: <code>ExtractionMethod</code></p> <p>Method name: <code>geometry_to_bbox</code></p> <p>Accepts a geometry with type and list of coordinates to <code>RFC 7946, section 5 &lt;https://tools.ietf.org/html/rfc7946#section-5&gt;</code>_ formatted bbox.</p> Example Configuration <p>.. code-block:: yaml</p> <pre><code>- method: geometry_to_bbox\n  inputs:\n    geometry:\n      type: point\n      coordinates:\n        - 20\n        - 0\n</code></pre> Source code in <code>extraction_methods/plugins/geometry_to_bbox.py</code> <pre><code>class GeometryToBboxExtract(ExtractionMethod):\n    \"\"\"\n    **Method name:** ``geometry_to_bbox``\n\n    Accepts a geometry with type and list of coordinates to `RFC 7946,\n    section 5 &lt;https://tools.ietf.org/html/rfc7946#section-5&gt;`_ formatted bbox.\n\n    Example Configuration:\n        .. code-block:: yaml\n\n            - method: geometry_to_bbox\n              inputs:\n                geometry:\n                  type: point\n                  coordinates:\n                    - 20\n                    - 0\n    \"\"\"\n\n    input_class = GeometryToBboxInput\n\n    def point(self, coordinates: list[float]) -&gt; list[float]:\n        \"\"\"\n        Get point bbox\n\n        :param coordinates: list of coordinates\n        :type coordinates: list\n\n        :return: bounding box of coordinates\n        :rtype: list\n        \"\"\"\n\n        return [\n            coordinates[0],\n            coordinates[1],\n            coordinates[0],\n            coordinates[1],\n        ]\n\n    def line(self, coordinates: list[list[float]]) -&gt; list[float]:\n        \"\"\"\n        Get line bbox\n\n        :param coordinates: list of coordinates\n        :type coordinates: list\n\n        :return: bounding box of coordinates\n        :rtype: list\n        \"\"\"\n\n        bbox = self.point(coordinates[0])\n\n        for coordinate in coordinates[1:]:\n\n            if coordinate[0] &lt; bbox[0]:\n                bbox[0] = coordinate[0]\n\n            elif coordinate[0] &gt; bbox[2]:\n                bbox[2] = coordinate[0]\n\n            if coordinate[1] &lt; bbox[1]:\n                bbox[1] = coordinate[1]\n\n            elif coordinate[1] &gt; bbox[3]:\n                bbox[3] = coordinate[1]\n\n        return bbox\n\n    def polygon(self, coordinates: list[list[float]]) -&gt; list[float]:\n        \"\"\"\n        Get polygon bbox\n\n        :param coordinates: list of coordinates\n        :type coordinates: list\n\n        :return: bounding box of coordinates\n        :rtype: list\n        \"\"\"\n\n        return self.line(coordinates[1:])\n\n    def multi(self, coordinate_type: str, coordinates: list[Any]) -&gt; list[float]:\n        \"\"\"\n        Get polygon bbox\n\n        :param coordinate_type: type of coordinates\n        :type coordinate_type: str\n        :param coordinates: list of coordinates\n        :type coordinates: list\n\n        :return: bounding box of coordinates\n        :rtype: list\n        \"\"\"\n\n        bboxes = [\n            self.get_bbox(coordinate_type.lstrip(\"Multi\"), coordinate)\n            for coordinate in coordinates\n        ]\n        return [\n            min(bbox[0] for bbox in bboxes),\n            max(bbox[2] for bbox in bboxes),\n            min(bbox[1] for bbox in bboxes),\n            max(bbox[3] for bbox in bboxes),\n        ]\n\n    def get_bbox(self, coordinate_type: str, coordinates: list[Any]) -&gt; list[float]:\n        \"\"\"\n        Get bbox from geometry\n\n        :param coordinate_type: type of coordinates\n        :type coordinate_type: str\n        :param coordinates: list of coordinates\n        :type coordinates: list\n\n        :return: bounding box of coordinates\n        :rtype: list\n        \"\"\"\n\n        if coordinate_type == \"Point\":\n            return self.point(coordinates)\n\n        if coordinate_type == \"Line\":\n            return self.line(coordinates)\n\n        if coordinate_type == \"Polygon\":\n            return self.polygon(coordinates[0])\n\n        if coordinate_type.startswith(\"Multi\"):\n            return self.multi(coordinate_type, coordinates)\n\n        return []\n\n    @update_input\n    def run(self, body: dict[str, Any]) -&gt; dict[str, Any]:\n\n        body[self.input.output_key] = self.get_bbox(\n            self.input.geometry[\"type\"], self.input.geometry[\"coordinates\"]\n        )\n\n        return body\n</code></pre>"},{"location":"geometry_to_bbox/#extraction_methods.plugins.geometry_to_bbox.GeometryToBboxExtract.get_bbox","title":"<code>get_bbox(coordinate_type, coordinates)</code>","text":"<p>Get bbox from geometry</p> <p>:param coordinate_type: type of coordinates :type coordinate_type: str :param coordinates: list of coordinates :type coordinates: list</p> <p>:return: bounding box of coordinates :rtype: list</p> Source code in <code>extraction_methods/plugins/geometry_to_bbox.py</code> <pre><code>def get_bbox(self, coordinate_type: str, coordinates: list[Any]) -&gt; list[float]:\n    \"\"\"\n    Get bbox from geometry\n\n    :param coordinate_type: type of coordinates\n    :type coordinate_type: str\n    :param coordinates: list of coordinates\n    :type coordinates: list\n\n    :return: bounding box of coordinates\n    :rtype: list\n    \"\"\"\n\n    if coordinate_type == \"Point\":\n        return self.point(coordinates)\n\n    if coordinate_type == \"Line\":\n        return self.line(coordinates)\n\n    if coordinate_type == \"Polygon\":\n        return self.polygon(coordinates[0])\n\n    if coordinate_type.startswith(\"Multi\"):\n        return self.multi(coordinate_type, coordinates)\n\n    return []\n</code></pre>"},{"location":"geometry_to_bbox/#extraction_methods.plugins.geometry_to_bbox.GeometryToBboxExtract.line","title":"<code>line(coordinates)</code>","text":"<p>Get line bbox</p> <p>:param coordinates: list of coordinates :type coordinates: list</p> <p>:return: bounding box of coordinates :rtype: list</p> Source code in <code>extraction_methods/plugins/geometry_to_bbox.py</code> <pre><code>def line(self, coordinates: list[list[float]]) -&gt; list[float]:\n    \"\"\"\n    Get line bbox\n\n    :param coordinates: list of coordinates\n    :type coordinates: list\n\n    :return: bounding box of coordinates\n    :rtype: list\n    \"\"\"\n\n    bbox = self.point(coordinates[0])\n\n    for coordinate in coordinates[1:]:\n\n        if coordinate[0] &lt; bbox[0]:\n            bbox[0] = coordinate[0]\n\n        elif coordinate[0] &gt; bbox[2]:\n            bbox[2] = coordinate[0]\n\n        if coordinate[1] &lt; bbox[1]:\n            bbox[1] = coordinate[1]\n\n        elif coordinate[1] &gt; bbox[3]:\n            bbox[3] = coordinate[1]\n\n    return bbox\n</code></pre>"},{"location":"geometry_to_bbox/#extraction_methods.plugins.geometry_to_bbox.GeometryToBboxExtract.multi","title":"<code>multi(coordinate_type, coordinates)</code>","text":"<p>Get polygon bbox</p> <p>:param coordinate_type: type of coordinates :type coordinate_type: str :param coordinates: list of coordinates :type coordinates: list</p> <p>:return: bounding box of coordinates :rtype: list</p> Source code in <code>extraction_methods/plugins/geometry_to_bbox.py</code> <pre><code>def multi(self, coordinate_type: str, coordinates: list[Any]) -&gt; list[float]:\n    \"\"\"\n    Get polygon bbox\n\n    :param coordinate_type: type of coordinates\n    :type coordinate_type: str\n    :param coordinates: list of coordinates\n    :type coordinates: list\n\n    :return: bounding box of coordinates\n    :rtype: list\n    \"\"\"\n\n    bboxes = [\n        self.get_bbox(coordinate_type.lstrip(\"Multi\"), coordinate)\n        for coordinate in coordinates\n    ]\n    return [\n        min(bbox[0] for bbox in bboxes),\n        max(bbox[2] for bbox in bboxes),\n        min(bbox[1] for bbox in bboxes),\n        max(bbox[3] for bbox in bboxes),\n    ]\n</code></pre>"},{"location":"geometry_to_bbox/#extraction_methods.plugins.geometry_to_bbox.GeometryToBboxExtract.point","title":"<code>point(coordinates)</code>","text":"<p>Get point bbox</p> <p>:param coordinates: list of coordinates :type coordinates: list</p> <p>:return: bounding box of coordinates :rtype: list</p> Source code in <code>extraction_methods/plugins/geometry_to_bbox.py</code> <pre><code>def point(self, coordinates: list[float]) -&gt; list[float]:\n    \"\"\"\n    Get point bbox\n\n    :param coordinates: list of coordinates\n    :type coordinates: list\n\n    :return: bounding box of coordinates\n    :rtype: list\n    \"\"\"\n\n    return [\n        coordinates[0],\n        coordinates[1],\n        coordinates[0],\n        coordinates[1],\n    ]\n</code></pre>"},{"location":"geometry_to_bbox/#extraction_methods.plugins.geometry_to_bbox.GeometryToBboxExtract.polygon","title":"<code>polygon(coordinates)</code>","text":"<p>Get polygon bbox</p> <p>:param coordinates: list of coordinates :type coordinates: list</p> <p>:return: bounding box of coordinates :rtype: list</p> Source code in <code>extraction_methods/plugins/geometry_to_bbox.py</code> <pre><code>def polygon(self, coordinates: list[list[float]]) -&gt; list[float]:\n    \"\"\"\n    Get polygon bbox\n\n    :param coordinates: list of coordinates\n    :type coordinates: list\n\n    :return: bounding box of coordinates\n    :rtype: list\n    \"\"\"\n\n    return self.line(coordinates[1:])\n</code></pre>"},{"location":"geometry_to_bbox/#extraction_methods.plugins.geometry_to_bbox.GeometryToBboxInput","title":"<code>GeometryToBboxInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for Geometry to Bounding Box Input.</p> <p>Parameters:</p> Name Type Description Default <code>geometry</code> <code>dict[str, Any]</code> <p>geometry to be converted to bbox.</p> <code>'$geometry'</code> <code>output_key</code> <code>str</code> <p>key to output to.</p> <code>'bbox'</code> Source code in <code>extraction_methods/plugins/geometry_to_bbox.py</code> <pre><code>class GeometryToBboxInput(Input):\n    \"\"\"\n    Model for Geometry to Bounding Box Input.\n    \"\"\"\n\n    geometry: dict[str, Any] = Field(  # type: ignore[assignment]\n        default=\"$geometry\",\n        description=\"geometry to be converted to bbox.\",\n    )\n    output_key: str = Field(\n        default=\"bbox\",\n        description=\"key to output to.\",\n    )\n</code></pre>"},{"location":"hash/","title":"Hash","text":""},{"location":"hash/#extraction_methods.plugins.hash.HashExtract","title":"<code>HashExtract</code>","text":"<p>               Bases: <code>ExtractionMethod</code></p> <p>Method name: <code>hash</code></p> <p>Hashes input string.</p> Example configuration <p>.. code-block:: yaml</p> <pre><code>- method: hash\n  inputs:\n    hash_str: $model\n    output_key: hashed_terms\n</code></pre> Source code in <code>extraction_methods/plugins/hash.py</code> <pre><code>class HashExtract(ExtractionMethod):\n    \"\"\"\n    **Method name:** ``hash``\n\n    Hashes input string.\n\n    Example configuration:\n        .. code-block:: yaml\n\n            - method: hash\n              inputs:\n                hash_str: $model\n                output_key: hashed_terms\n    \"\"\"\n\n    input_class = HashInput\n\n    @update_input\n    def run(self, body: dict[str, Any]) -&gt; dict[str, Any]:\n\n        body[self.input.output_key] = hashlib.md5(\n            self.input.input_term.encode(\"utf-8\"), usedforsecurity=False\n        ).hexdigest()\n\n        return body\n</code></pre>"},{"location":"hash/#extraction_methods.plugins.hash.HashInput","title":"<code>HashInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for Hash Input.</p> <p>Parameters:</p> Name Type Description Default <code>hash_str</code> <code>str</code> <p>string to be hashed.</p> required <code>output_key</code> <code>str</code> <p>key to output to.</p> required Source code in <code>extraction_methods/plugins/hash.py</code> <pre><code>class HashInput(Input):\n    \"\"\"\n    Model for Hash Input.\n    \"\"\"\n\n    hash_str: str = Field(\n        description=\"string to be hashed.\",\n    )\n    output_key: str = Field(\n        description=\"key to output to.\",\n    )\n</code></pre>"},{"location":"intake_esm/","title":"Intake esm","text":""},{"location":"intake_esm/#extraction_methods.plugins.intake_esm.IntakeESMExtract","title":"<code>IntakeESMExtract</code>","text":"<p>               Bases: <code>ExtractionMethod</code></p> <p>Method name: <code>intake</code></p> <p>Performs Search on intake catalog. Uses an <code>Intake catalog &lt;https://intake.readthedocs.io/&gt;</code>_ as a source for file objects.</p> Example Configuration <p>.. code-block:: yaml</p> <pre><code>- method: intake_esm\n  inputs:\n    href_term: url\n</code></pre> Source code in <code>extraction_methods/plugins/intake_esm.py</code> <pre><code>class IntakeESMExtract(ExtractionMethod):\n    \"\"\"\n    **Method name:** ``intake``\n\n    Performs Search on intake catalog.\n    Uses an `Intake catalog &lt;https://intake.readthedocs.io/&gt;`_\n    as a source for file objects.\n\n    Example Configuration:\n        .. code-block:: yaml\n\n            - method: intake_esm\n              inputs:\n                href_term: url\n    \"\"\"\n\n    input_class = IntakeESMInput\n\n    @update_input\n    def run(self, body: dict[str, Any]) -&gt; dict[str, Any]:\n\n        catalog = intake.open_esm_datastore(\n            self.input.input_term, **self.input.datastore_kwargs\n        )\n\n        if search_kwargs := self.input.search_kwargs:\n            catalog = catalog.search(**search_kwargs)\n\n        body[self.input.output_key] = catalog.df.items()\n\n        return body\n</code></pre>"},{"location":"intake_esm/#extraction_methods.plugins.intake_esm.IntakeESMInput","title":"<code>IntakeESMInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for IntakeESM Assets Backend Input.</p> <p>Parameters:</p> Name Type Description Default <code>input_term</code> <code>str</code> <p>term for method to run on.</p> <code>'$uri'</code> <code>datastore_kwargs</code> <code>dict[str, Any]</code> <p>kwargs to open datastore.</p> <code>{}</code> <code>search_kwargs</code> <code>dict[str, Any]</code> <p>kwargs for search.</p> <code>{}</code> <code>output_key</code> <code>str</code> <p>key to output to.</p> <code>'label'</code> Source code in <code>extraction_methods/plugins/intake_esm.py</code> <pre><code>class IntakeESMInput(Input):\n    \"\"\"\n    Model for IntakeESM Assets Backend Input.\n    \"\"\"\n\n    input_term: str = Field(\n        default=\"$uri\",\n        description=\"term for method to run on.\",\n    )\n    datastore_kwargs: dict[str, Any] = Field(\n        default={},\n        description=\"kwargs to open datastore.\",\n    )\n    search_kwargs: dict[str, Any] = Field(\n        default={},\n        description=\"kwargs for search.\",\n    )\n    output_key: str = Field(\n        default=\"label\",\n        description=\"key to output to.\",\n    )\n</code></pre>"},{"location":"iso19115/","title":"Iso19115","text":""},{"location":"iso19115/#extraction_methods.plugins.iso19115.ISO19115Extract","title":"<code>ISO19115Extract</code>","text":"<p>               Bases: <code>ExtractionMethod</code></p> <p>Method name: <code>iso19115</code></p> <p>Takes a URL and calls out to URL to retrieve the iso19115 record.</p> Example configuration <p>.. code-block:: yaml</p> <pre><code>- method: iso19115\n  inputs:\n    url: $url\n    dates:\n      - key: './/gml:beginPosition'\n        output_key: start_datetime\n</code></pre> Source code in <code>extraction_methods/plugins/iso19115.py</code> <pre><code>class ISO19115Extract(ExtractionMethod):\n    \"\"\"\n    **Method name:** ``iso19115``\n\n    Takes a URL and calls out to URL to retrieve the iso19115 record.\n\n    Example configuration:\n        .. code-block:: yaml\n\n            - method: iso19115\n              inputs:\n                url: $url\n                dates:\n                  - key: './/gml:beginPosition'\n                    output_key: start_datetime\n    \"\"\"\n\n    input_class = ISO19115Input\n\n    @update_input\n    def run(self, body: dict[str, Any]) -&gt; dict[str, Any]:\n\n        # Retrieve the ISO 19115 record\n        response = httpx.get(self.input.url, timeout=self.input.request_timeout)\n\n        if not response.status_code == 200:\n            LOGGER.debug(\n                \"Request %s failed with response: %s\", self.input.url, response.text\n            )\n            return body\n\n        iso_record = ET.fromstring(response.text)\n\n        # Extract the keys\n        for extraction_term in self.input.dates:\n            value = iso_record.find(extraction_term.key, iso19115_ns)\n\n            if value is not None:\n                body[extraction_term.output_key] = value.text\n\n        return body\n</code></pre>"},{"location":"iso19115/#extraction_methods.plugins.iso19115.ISO19115Input","title":"<code>ISO19115Input</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for ISO19115 Date Input.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Url for record store.</p> required <code>dates</code> <code>list[KeyOutputKey]</code> <p>list of dates to extract.</p> required <code>request_timeout</code> <code>int</code> <p>request time out.</p> <code>15</code> Source code in <code>extraction_methods/plugins/iso19115.py</code> <pre><code>class ISO19115Input(Input):\n    \"\"\"\n    Model for ISO19115 Date Input.\n    \"\"\"\n\n    url: str = Field(\n        description=\"Url for record store.\",\n    )\n    dates: list[KeyOutputKey] = Field(\n        description=\"list of dates to extract.\",\n    )\n    request_timeout: int = Field(\n        default=15,\n        description=\"request time out.\",\n    )\n</code></pre>"},{"location":"iso_date/","title":"Iso date","text":""},{"location":"iso_date/#extraction_methods.plugins.iso_date.DateTerm","title":"<code>DateTerm</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for Date terms with format.</p> <p>Parameters:</p> Name Type Description Default <code>input_term</code> <code>str</code> <p>Term to run method on.</p> required <code>format</code> <code>str</code> <p>Format of the date.</p> <code>'%Y-%m-%dT%H:%M:%SZ'</code> <code>output_key</code> <code>str</code> <p>Key to output to.</p> <code>'datetime'</code> Source code in <code>extraction_methods/plugins/iso_date.py</code> <pre><code>class DateTerm(BaseModel):\n    \"\"\"\n    Model for Date terms with format.\n    \"\"\"\n\n    input_term: str = Field(\n        description=\"Term to run method on.\",\n    )\n    format: str = Field(\n        default=\"%Y-%m-%dT%H:%M:%SZ\",\n        description=\"Format of the date.\",\n    )\n    output_key: str = Field(\n        default=\"datetime\",\n        description=\"Key to output to.\",\n    )\n</code></pre>"},{"location":"iso_date/#extraction_methods.plugins.iso_date.ISODateExtract","title":"<code>ISODateExtract</code>","text":"<p>               Bases: <code>ExtractionMethod</code></p> <p>Method name: <code>iso_date</code></p> <p>Takes the source dict and the key to access the date and converts the date to ISO 8601 Format.</p> <p>e.g.</p> <p><code>YYYY-MM-DDTHH:MM:SS.ffffff</code>, if microsecond is not 0 <code>YYYY-MM-DDTHH:MM:SS</code>, if microsecond is 0</p> <p>If the date format cannot be parsed, it is removed from the source dict with an error logged.</p> Example Configuration <p>.. code-block:: yaml</p> <pre><code>- method: iso_date\n  inputs:\n    dates:\n      - key: $datetime\n        output_key: date\n        format: \"%Y-%m-%dT%H:%M:%S\"\n      - key: 2012-12-12\n        format: \"%Y-%m-%d\"\n</code></pre> Source code in <code>extraction_methods/plugins/iso_date.py</code> <pre><code>class ISODateExtract(ExtractionMethod):\n    \"\"\"\n    **Method name:** ``iso_date``\n\n    Takes the source dict and the key to access the date and\n    converts the date to ISO 8601 Format.\n\n    e.g.\n\n    ``YYYY-MM-DDTHH:MM:SS.ffffff``, if microsecond is not 0\n    ``YYYY-MM-DDTHH:MM:SS``, if microsecond is 0\n\n    If the date format cannot be parsed, it is removed from the source dict with\n    an error logged.\n\n    Example Configuration:\n        .. code-block:: yaml\n\n            - method: iso_date\n              inputs:\n                dates:\n                  - key: $datetime\n                    output_key: date\n                    format: \"%Y-%m-%dT%H:%M:%S\"\n                  - key: 2012-12-12\n                    format: \"%Y-%m-%d\"\n    \"\"\"\n\n    input_class = ISODateInput\n\n    @update_input\n    def run(self, body: dict[str, Any]) -&gt; dict[str, Any]:\n\n        for date_term in self.input.date_terms:\n\n            if not date_term:\n                LOGGER.error(\"%s not present in %s\", date_term.input_term, body)\n\n            else:\n\n                try:\n                    date_iso = datetime.strptime(\n                        date_term.input_term, date_term.format\n                    ).isoformat()\n                    body[date_term.output_key] = date_iso\n\n                except ValueError:\n                    LOGGER.error(\n                        \"date_term: %s doesn't match format: %s\",\n                        date_term.input_term,\n                        date_term.format,\n                    )\n\n        return body\n</code></pre>"},{"location":"iso_date/#extraction_methods.plugins.iso_date.ISODateInput","title":"<code>ISODateInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for ISO Date Input.</p> <p>Parameters:</p> Name Type Description Default <code>date_terms</code> <code>list[DateTerm]</code> <p>List of date terms.</p> <code>[]</code> Source code in <code>extraction_methods/plugins/iso_date.py</code> <pre><code>class ISODateInput(Input):\n    \"\"\"\n    Model for ISO Date Input.\n    \"\"\"\n\n    date_terms: list[DateTerm] = Field(\n        default=[],\n        description=\"List of date terms.\",\n    )\n</code></pre>"},{"location":"json_file/","title":"Json file","text":""},{"location":"json_file/#extraction_methods.plugins.json_file.JsonFileExtract","title":"<code>JsonFileExtract</code>","text":"<p>               Bases: <code>ExtractionMethod</code></p> <p>Method name: <code>json_file</code></p> <p>Takes an input list of string to extract from the json file.</p> Example configuration <p>.. code-block:: yaml</p> <pre><code>- method: json_file\n  inputs:\n    path: /path/to/file.json\n    properties:\n      - key: MIP_ERA\n        output_key: mip_era\n</code></pre> Source code in <code>extraction_methods/plugins/json_file.py</code> <pre><code>class JsonFileExtract(ExtractionMethod):\n    \"\"\"\n    **Method name:** ``json_file``\n\n    Takes an input list of string to extract from the json file.\n\n    Example configuration:\n        .. code-block:: yaml\n\n            - method: json_file\n              inputs:\n                path: /path/to/file.json\n                properties:\n                  - key: MIP_ERA\n                    output_key: mip_era\n    \"\"\"\n\n    input_class = JsonFileInput\n\n    def extract_terms(self, path: Path) -&gt; dict[str, Any]:\n        \"\"\"\n        Extract terms from JSON file(s) at path.\n\n        :param path: path to file\n        :type path: Path\n\n        :return: extracted terms\n        :rtype: dict\n        \"\"\"\n\n        try:\n            with open(path, \"r\", encoding=\"utf-8\") as json_file:\n                load_out = json.load(json_file)\n        except ValueError as error:\n            LOGGER.debug(\"File: %s can't be json loaded: %s\", path, error)\n\n        output = {}\n        for term in self.input.properties:\n            if term.key in load_out:\n                output[term.output_key] = load_out[term.key]\n\n        return output\n\n    @update_input\n    def run(self, body: dict[str, Any]) -&gt; dict[str, Any]:\n\n        path = Path(self.input.path)\n\n        if path.is_dir():\n            output: dict[str, Any] = defaultdict(list)\n            for child in path.rglob(\"*.json\"):\n                for k, v in self.extract_terms(child):\n                    if isinstance(v, list):\n                        output[k].extend(v)\n                    else:\n                        output[k].append(v)\n\n        if path.is_file():\n            output = {path.name: self.extract_terms(path)}\n\n        return body | output\n</code></pre>"},{"location":"json_file/#extraction_methods.plugins.json_file.JsonFileExtract.extract_terms","title":"<code>extract_terms(path)</code>","text":"<p>Extract terms from JSON file(s) at path.</p> <p>:param path: path to file :type path: Path</p> <p>:return: extracted terms :rtype: dict</p> Source code in <code>extraction_methods/plugins/json_file.py</code> <pre><code>def extract_terms(self, path: Path) -&gt; dict[str, Any]:\n    \"\"\"\n    Extract terms from JSON file(s) at path.\n\n    :param path: path to file\n    :type path: Path\n\n    :return: extracted terms\n    :rtype: dict\n    \"\"\"\n\n    try:\n        with open(path, \"r\", encoding=\"utf-8\") as json_file:\n            load_out = json.load(json_file)\n    except ValueError as error:\n        LOGGER.debug(\"File: %s can't be json loaded: %s\", path, error)\n\n    output = {}\n    for term in self.input.properties:\n        if term.key in load_out:\n            output[term.output_key] = load_out[term.key]\n\n    return output\n</code></pre>"},{"location":"json_file/#extraction_methods.plugins.json_file.JsonFileInput","title":"<code>JsonFileInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for JSON File Input.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to directory of JSON files or single JSON file.</p> required <code>properties</code> <code>list[KeyOutputKey]</code> <p>list of properties to extract.</p> required Source code in <code>extraction_methods/plugins/json_file.py</code> <pre><code>class JsonFileInput(Input):\n    \"\"\"\n    Model for JSON File Input.\n    \"\"\"\n\n    path: str = Field(\n        description=\"Path to directory of JSON files or single JSON file.\",\n    )\n    properties: list[KeyOutputKey] = Field(\n        description=\"list of properties to extract.\",\n    )\n</code></pre>"},{"location":"lambda/","title":"Lambda","text":""},{"location":"lambda/#extraction_methods.plugins.lambda.LambdaExtract","title":"<code>LambdaExtract</code>","text":"<p>               Bases: <code>ExtractionMethod</code></p> <p>Method name: <code>lambda</code></p> <p>Accepts a dictionary. String values are popped from the dictionary and are put back into the dictionary with the <code>key</code> specified.</p> Example Configuration <p>.. code-block:: yaml</p> <pre><code>- method: lambda\n  inputs:\n    function: 'lambda x: x * x'\n    args:\n      - hello\n      - $world\n    kwargs:\n      hello: world\n      goodbye: all\n</code></pre> Source code in <code>extraction_methods/plugins/lambda.py</code> <pre><code>class LambdaExtract(ExtractionMethod):\n    \"\"\"\n    **Method name:** ``lambda``\n\n    Accepts a dictionary. String values are popped from the dictionary and\n    are put back into the dictionary with the ``key`` specified.\n\n    Example Configuration:\n        .. code-block:: yaml\n\n            - method: lambda\n              inputs:\n                function: 'lambda x: x * x'\n                args:\n                  - hello\n                  - $world\n                kwargs:\n                  hello: world\n                  goodbye: all\n    \"\"\"\n\n    input_class = LambdaInput\n\n    @update_input\n    def run(self, body: dict[str, Any]) -&gt; dict[str, Any]:\n\n        output_body = body.copy()\n\n        function = eval(self.input.function)  # nosec B307\n\n        result = function(*self.input.args, **self.input.kwargs)\n\n        if self.input.output_key:\n            output_body[self.input.output_key] = result\n\n        elif isinstance(result, dict):\n            output_body |= result\n\n        return output_body\n</code></pre>"},{"location":"lambda/#extraction_methods.plugins.lambda.LambdaInput","title":"<code>LambdaInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for Lambda Input.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>str</code> <p>lambda function to be run.</p> required <code>args</code> <code>list[Any]</code> <p>list of arguments for function.</p> <code>[]</code> <code>kwargs</code> <code>dict[str, Any]</code> <p>dictionary of key word arguments for function.</p> <code>{}</code> <code>output_key</code> <code>str</code> <p>key to output to.</p> <code>'label'</code> Source code in <code>extraction_methods/plugins/lambda.py</code> <pre><code>class LambdaInput(Input):  # type: ignore[no-redef]\n    \"\"\"\n    Model for Lambda Input.\n    \"\"\"\n\n    function: str = Field(\n        description=\"lambda function to be run.\",\n    )\n    args: list[Any] = Field(\n        default=[],\n        description=\"list of arguments for function.\",\n    )\n    kwargs: dict[str, Any] = Field(\n        default={},\n        description=\"dictionary of key word arguments for function.\",\n    )\n    output_key: str = Field(\n        default=\"label\",\n        description=\"key to output to.\",\n    )\n</code></pre>"},{"location":"netcdf/","title":"Netcdf","text":""},{"location":"netcdf/#extraction_methods.plugins.netcdf.NetCDFExtract","title":"<code>NetCDFExtract</code>","text":"<p>               Bases: <code>ExtractionMethod</code></p> <p>Method name: <code>netcdf</code></p> <p>Description:  Processes XML documents to extract metadata</p> Example configuration <p>.. code-block:: yaml</p> <pre><code>- method: xml\n  inputs:\n    filter_expr: '\\.manifest$'\n    extraction_keys:\n      - name: start_datetime\n        key: './/gml:beginPosition'\n        attribute: start\n</code></pre>"},{"location":"netcdf/#extraction_methods.plugins.netcdf.NetCDFExtract--noqa-w605","title":"noqa: W605","text":"Source code in <code>extraction_methods/plugins/netcdf.py</code> <pre><code>class NetCDFExtract(ExtractionMethod):\n    \"\"\"\n    **Method name:** ``netcdf``\n\n    Description:  Processes XML documents to extract metadata\n\n    Example configuration:\n        .. code-block:: yaml\n\n            - method: xml\n              inputs:\n                filter_expr: '\\.manifest$'\n                extraction_keys:\n                  - name: start_datetime\n                    key: './/gml:beginPosition'\n                    attribute: start\n\n    # noqa: W605\n    \"\"\"\n\n    input_class = NetCDFInput\n\n    @update_input\n    def run(self, body: dict[str, Any]) -&gt; dict[str, Any]:\n\n        dataset = xarray.open_dataset(self.input.input_term, decode_coords=\"all\")\n\n        if self.input.variable_attributes:\n            variable = dataset[self.input.variable_id]\n            variable_attrs = variable.attrs\n\n            for variable_attribute in self.input.variable_attributes:\n                body[variable_attribute.output_key] = variable_attrs.get(\n                    variable_attribute.key, None\n                )\n\n        if self.input.global_attributes:\n            global_attrs = dataset.attrs\n\n            for global_attribute in self.input.global_attributes:\n                body[global_attribute.output_key] = global_attrs.get(\n                    global_attribute.key, None\n                )\n\n        if self.input.cf_attributes:\n            cf_attrs = dataset.cf\n\n            for cf_attribute in self.input.cf_attributes:\n                try:\n                    body[cf_attribute.output_key] = cf_attrs[cf_attribute.key]\n\n                except KeyError:\n                    body[cf_attribute.output_key] = None\n\n        if self.input.rio_attributes:\n            rio_attrs = dataset.rio\n\n            for rio_attribute in self.input.rio_attributes:\n                body[rio_attribute.output_key] = getattr(\n                    rio_attrs, rio_attribute.key, None\n                )\n\n        return body\n</code></pre>"},{"location":"netcdf/#extraction_methods.plugins.netcdf.NetCDFInput","title":"<code>NetCDFInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for NetCDF Input.</p> <p>Parameters:</p> Name Type Description Default <code>input_term</code> <code>str</code> <p>term for method to run on.</p> <code>'$uri'</code> <code>variable_id</code> <code>str</code> <p>lambda function to be run.</p> <code>'$uri'</code> <code>variable_attributes</code> <code>list[KeyOutputKey]</code> <p>list of variable attributes to extract.</p> <code>[]</code> <code>global_attributes</code> <code>list[KeyOutputKey]</code> <p>list of global attributes to extract.</p> <code>[]</code> <code>cf_attributes</code> <code>list[KeyOutputKey]</code> <p>list of cf attributes to extract.</p> <code>[]</code> <code>rio_attributes</code> <code>list[KeyOutputKey]</code> <p>list of rio attributes to extract.</p> <code>[]</code> Source code in <code>extraction_methods/plugins/netcdf.py</code> <pre><code>class NetCDFInput(Input):\n    \"\"\"\n    Model for NetCDF Input.\n    \"\"\"\n\n    input_term: str = Field(\n        default=\"$uri\",\n        description=\"term for method to run on.\",\n    )\n    variable_id: str = Field(\n        default=\"$uri\",\n        description=\"lambda function to be run.\",\n    )\n    variable_attributes: list[KeyOutputKey] = Field(\n        default=[],\n        description=\"list of variable attributes to extract.\",\n    )\n    global_attributes: list[KeyOutputKey] = Field(\n        default=[],\n        description=\"list of global attributes to extract.\",\n    )\n    cf_attributes: list[KeyOutputKey] = Field(\n        default=[],\n        description=\"list of cf attributes to extract.\",\n    )\n    rio_attributes: list[KeyOutputKey] = Field(\n        default=[],\n        description=\"list of rio attributes to extract.\",\n    )\n</code></pre>"},{"location":"open_zip/","title":"Open zip","text":""},{"location":"open_zip/#extraction_methods.plugins.open_zip.ZipExtract","title":"<code>ZipExtract</code>","text":"<p>               Bases: <code>ExtractionMethod</code></p> <p>Method name: <code>open_zip</code></p> <p>Open a zip file and read inner files</p> Example configuration <p>.. code-block:: yaml</p> <pre><code>- method: open_zip\n  inputs:\n    input_term: /path/to/a/file\n    inner_files:\n      - key: hello.txt\n        output_key: world\n</code></pre>"},{"location":"open_zip/#extraction_methods.plugins.open_zip.ZipExtract--noqa-w605","title":"noqa: W605","text":"Source code in <code>extraction_methods/plugins/open_zip.py</code> <pre><code>class ZipExtract(ExtractionMethod):\n    \"\"\"\n    **Method name:** ``open_zip``\n\n    Open a zip file and read inner files\n\n    Example configuration:\n        .. code-block:: yaml\n\n            - method: open_zip\n              inputs:\n                input_term: /path/to/a/file\n                inner_files:\n                  - key: hello.txt\n                    output_key: world\n\n    # noqa: W605\n    \"\"\"\n\n    input_class = ZipInput\n\n    @update_input\n    def run(self, body: dict[str, Any]) -&gt; dict[str, Any]:\n\n        # Extract the keys\n        with zipfile.ZipFile(self.input.input_term) as z:\n            if not self.input.inner_files:\n                body[self.input.output_key] = z.read()  # type: ignore[call-arg]\n\n            else:\n                output: dict[str, Any] = {}\n\n                for inner_file in self.input.inner_files:\n                    output[inner_file.output_key] = z.read(inner_file.key)\n\n                if self.input.output_key:\n                    body[self.input.output_key] = output\n\n                else:\n                    body |= output\n\n        return body\n</code></pre>"},{"location":"open_zip/#extraction_methods.plugins.open_zip.ZipInput","title":"<code>ZipInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for Zip Input.</p> <p>Parameters:</p> Name Type Description Default <code>input_term</code> <code>str</code> <p>term for method to run on.</p> <code>'$uri'</code> <code>inner_files</code> <code>list[KeyOutputKey]</code> <p>list of inner zipped files to be read.</p> <code>[]</code> <code>output_key</code> <code>str</code> <p>key to output to.</p> <code>''</code> Source code in <code>extraction_methods/plugins/open_zip.py</code> <pre><code>class ZipInput(Input):\n    \"\"\"\n    Model for Zip Input.\n    \"\"\"\n\n    input_term: str = Field(\n        default=\"$uri\",\n        description=\"term for method to run on.\",\n    )\n    inner_files: list[KeyOutputKey] = Field(\n        default=[],\n        description=\"list of inner zipped files to be read.\",\n    )\n    output_key: str = Field(\n        default=\"\",\n        description=\"key to output to.\",\n    )\n\n    @model_validator(mode=\"after\")\n    def check_root_read(self) -&gt; Self:\n        if not self.output_key and not self.inner_files:\n            raise ValueError(\"`output_key` required if no `inner_files` defined\")\n        return self\n</code></pre>"},{"location":"path_parts/","title":"Path parts","text":""},{"location":"path_parts/#extraction_methods.plugins.path_parts.PathPartsExtract","title":"<code>PathPartsExtract</code>","text":"<p>               Bases: <code>ExtractionMethod</code></p> <p>Method name: <code>path_parts</code></p> <p>Extracts the parts of a given path skipping <code>skip</code> number of top level parts.</p> Example configuration <p>.. code-block:: yaml</p> <pre><code>- method: path_parts\n  inputs:\n    input_term: $uri\n    skip: 2\n</code></pre> Source code in <code>extraction_methods/plugins/path_parts.py</code> <pre><code>class PathPartsExtract(ExtractionMethod):\n    \"\"\"\n    **Method name:** ``path_parts``\n\n    Extracts the parts of a given path skipping ``skip`` number\n    of top level parts.\n\n    Example configuration:\n        .. code-block:: yaml\n\n            - method: path_parts\n              inputs:\n                input_term: $uri\n                skip: 2\n    \"\"\"\n\n    input_class = PathPartsInput\n\n    @update_input\n    def run(self, body: dict[str, Any]) -&gt; dict[str, Any]:\n\n        path = Path(self.input.path)\n\n        parts = list(path.parts)[self.input.skip :]\n\n        body[\"filename\"] = parts.pop()\n\n        dir_level = 1\n        for part in parts:\n            body[f\"_dir{dir_level}\"] = part\n            dir_level += 1\n\n        return body\n</code></pre>"},{"location":"path_parts/#extraction_methods.plugins.path_parts.PathPartsInput","title":"<code>PathPartsInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for Path Parts Input.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>path for method to run on.</p> <code>'$uri'</code> <code>skip</code> <code>int</code> <p>number of path parts to skip.</p> <code>0</code> Source code in <code>extraction_methods/plugins/path_parts.py</code> <pre><code>class PathPartsInput(Input):\n    \"\"\"\n    Model for Path Parts Input.\n    \"\"\"\n\n    path: str = Field(\n        default=\"$uri\",\n        description=\"path for method to run on.\",\n    )\n    skip: int = Field(\n        default=0,\n        description=\"number of path parts to skip.\",\n    )\n</code></pre>"},{"location":"regex/","title":"Regex","text":""},{"location":"regex/#extraction_methods.plugins.regex.RegexExtract","title":"<code>RegexExtract</code>","text":"<p>               Bases: <code>ExtractionMethod</code></p> <p>Method name: <code>regex</code></p> <p>Takes an input string and a regex with named capture groups and returns a dictionary of the values extracted using the named capture groups.</p> Example configuration <p>.. code-block:: yaml</p> <pre><code>- method: regex\n  inputs:\n    regex: ^(?:[^_]*_){2}(?P&lt;datetime&gt;\\d*)\n</code></pre>"},{"location":"regex/#extraction_methods.plugins.regex.RegexExtract--noqa-w605","title":"noqa: W605","text":"Source code in <code>extraction_methods/plugins/regex.py</code> <pre><code>class RegexExtract(ExtractionMethod):\n    \"\"\"\n    **Method name:** ``regex``\n\n    Takes an input string and a regex with\n    named capture groups and returns a dictionary of the values\n    extracted using the named capture groups.\n\n    Example configuration:\n        .. code-block:: yaml\n\n            - method: regex\n              inputs:\n                regex: ^(?:[^_]*_){2}(?P&lt;datetime&gt;\\d*)\n\n    # noqa: W605\n    \"\"\"\n\n    input_class = RegexInput\n\n    @update_input\n    def run(self, body: dict[str, Any]) -&gt; dict[str, Any]:\n\n        result = re.search(rf\"{self.input.regex}\", self.input.input_term)\n\n        if result:\n            body |= result.groupdict()\n\n        else:\n            LOGGER.debug(\"No matches found for regex extract\")\n\n        return body\n</code></pre>"},{"location":"regex/#extraction_methods.plugins.regex.RegexInput","title":"<code>RegexInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for Regex Input.</p> <p>Parameters:</p> Name Type Description Default <code>input_term</code> <code>str</code> <p>term for method to run on.</p> <code>'$uri'</code> <code>regex</code> <code>str</code> <p>The regular expression to match against.</p> required Source code in <code>extraction_methods/plugins/regex.py</code> <pre><code>class RegexInput(Input):\n    \"\"\"\n    Model for Regex Input.\n    \"\"\"\n\n    input_term: str = Field(\n        default=\"$uri\",\n        description=\"term for method to run on.\",\n    )\n    regex: str = Field(\n        description=\"The regular expression to match against.\",\n    )\n</code></pre>"},{"location":"regex_label/","title":"Regex label","text":""},{"location":"regex_label/#extraction_methods.plugins.regex_label.RegexLabelExtract","title":"<code>RegexLabelExtract</code>","text":"<p>               Bases: <code>ExtractionMethod</code></p> <p>Method name: <code>regex_label</code></p> <p>Adds label if full match of regex.</p> Example configuration <p>.. code-block:: yaml</p> <pre><code>- method: regex_label\n  inputs:\n    label: metadata\n    regex: README\n    allow_multiple: true\n</code></pre>"},{"location":"regex_label/#extraction_methods.plugins.regex_label.RegexLabelExtract--noqa-w605","title":"noqa: W605","text":"Source code in <code>extraction_methods/plugins/regex_label.py</code> <pre><code>class RegexLabelExtract(ExtractionMethod):\n    \"\"\"\n    **Method name:** ``regex_label``\n\n    Adds label if full match of regex.\n\n    Example configuration:\n        .. code-block:: yaml\n\n            - method: regex_label\n              inputs:\n                label: metadata\n                regex: README\n                allow_multiple: true\n\n    # noqa: W605\n    \"\"\"\n\n    input_class = RegexLabelInput\n\n    @update_input\n    def run(self, body: dict[str, Any]) -&gt; dict[str, Any]:\n\n        if re.fullmatch(rf\"{self.input.regex}\", self.input.input_term):\n            if self.input.allow_multiple:\n                body.setdefault(self.input.output_key, []).append(self.input.label)\n\n            else:\n                body[self.input.output_key] = self.input.label\n\n        return body\n</code></pre>"},{"location":"regex_label/#extraction_methods.plugins.regex_label.RegexLabelInput","title":"<code>RegexLabelInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for Regex Label Input.</p> <p>Parameters:</p> Name Type Description Default <code>input_term</code> <code>str</code> <p>term for method to run on.</p> <code>'$uri'</code> <code>label</code> <code>str</code> <p>Label to add if regex passes.</p> required <code>regex</code> <code>str</code> <p>Regex to test against.</p> required <code>allow_multiple</code> <code>bool</code> <p>True if multiple labels are allowed.</p> <code>True</code> <code>output_key</code> <code>str</code> <p>Term for method to output to.</p> <code>'label'</code> Source code in <code>extraction_methods/plugins/regex_label.py</code> <pre><code>class RegexLabelInput(Input):\n    \"\"\"\n    Model for Regex Label Input.\n    \"\"\"\n\n    input_term: str = Field(\n        default=\"$uri\",\n        description=\"term for method to run on.\",\n    )\n    label: str = Field(\n        description=\"Label to add if regex passes.\",\n    )\n    regex: str = Field(\n        description=\"Regex to test against.\",\n    )\n    allow_multiple: bool = Field(\n        default=True,\n        description=\"True if multiple labels are allowed.\",\n    )\n    output_key: str = Field(\n        default=\"label\",\n        description=\"Term for method to output to.\",\n    )\n</code></pre>"},{"location":"regex_rename/","title":"Regex rename","text":""},{"location":"regex_rename/#extraction_methods.plugins.regex_rename.RegexOutputKey","title":"<code>RegexOutputKey</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for Regex.</p> <p>Parameters:</p> Name Type Description Default <code>regex</code> <code>str</code> <p>Regex to test against.</p> required <code>output_key</code> <code>str</code> <p>Term for method to output to.</p> required Source code in <code>extraction_methods/plugins/regex_rename.py</code> <pre><code>class RegexOutputKey(Input):\n    \"\"\"\n    Model for Regex.\n    \"\"\"\n\n    regex: str = Field(\n        description=\"Regex to test against.\",\n    )\n    output_key: str = Field(\n        description=\"Term for method to output to.\",\n    )\n</code></pre>"},{"location":"regex_rename/#extraction_methods.plugins.regex_rename.RegexRenameExtract","title":"<code>RegexRenameExtract</code>","text":"<p>               Bases: <code>ExtractionMethod</code></p> <p>Method name: <code>regex_rename</code></p> <p>Takes a list of regex and output key combinations. Any existing properties that full match a regex are rename to the output key. Later regex take precedence.</p> Example configuration <p>.. code-block:: yaml</p> <pre><code>- method: regex_rename\n  inputs:\n    regex_swaps:\n      - regex: README\n        output_key: metadata\n</code></pre>"},{"location":"regex_rename/#extraction_methods.plugins.regex_rename.RegexRenameExtract--noqa-w605","title":"noqa: W605","text":"Source code in <code>extraction_methods/plugins/regex_rename.py</code> <pre><code>class RegexRenameExtract(ExtractionMethod):\n    \"\"\"\n    **Method name:** ``regex_rename``\n\n    Takes a list of regex and output key combinations. Any existing properties\n    that full match a regex are rename to the output key.\n    Later regex take precedence.\n\n    Example configuration:\n        .. code-block:: yaml\n\n            - method: regex_rename\n              inputs:\n                regex_swaps:\n                  - regex: README\n                    output_key: metadata\n\n    # noqa: W605\n    \"\"\"\n\n    input_class = RegexRenameInput\n\n    def matching_keys(self, keys: KeysView[str], key_regex: str) -&gt; list[str]:\n        \"\"\"\n        Find all keys that match regex\n\n        :param keys: dictionary keys to test\n        :type keys: KeysView\n        :param key_regex: regex to test against\n        :type key_regex: str\n\n        :return: matching keys\n        :rtype: list\n        \"\"\"\n\n        regex = re.compile(key_regex)\n\n        return list(filter(regex.match, keys))\n\n    def find(\n        self, body: dict[str, Any], key_parts: list[str]\n    ) -&gt; tuple[dict[str, Any], Any]:\n        \"\"\"\n        Rename terms\n\n        :param body: current body\n        :type body: dict\n        :param key_parts: key parts seperated by delimiter\n        :type key_parts: list\n\n        :return: dict\n        :rtype: update body\n        \"\"\"\n        value = None\n        for key in self.matching_keys(body.keys(), key_parts[0]):\n            if len(key_parts) &gt; 1:\n                body[key], value = self.find(body[key], key_parts[1:])\n\n            else:\n                value = body[key]\n                del body[key]\n\n        return body, value\n\n    def add(\n        self, body: dict[str, Any], key_parts: list[str], value: Any\n    ) -&gt; dict[str, Any]:\n        \"\"\"\n        Rename terms\n\n        :param body: current body\n        :type body: dict\n        :param key_parts: key parts seperated by delimiter\n        :type key_parts: list\n\n        :return: dict\n        :rtype: update body\n        \"\"\"\n        if len(key_parts) &gt; 1:\n            body[key_parts[0]] = self.add(body[key_parts[0]], key_parts[1:], value)\n\n        else:\n            body[key_parts[0]] = value\n\n        return body\n\n    @update_input\n    def run(self, body: dict[str, Any]) -&gt; dict[str, Any]:\n\n        for swap in self.input.regex_swaps:\n            key_parts = (\n                swap.regex.split(self.input.delimiter)\n                if self.input.delimiter\n                else [swap.regex]\n            )\n\n            output_key_parts = (\n                swap.output_key.split(self.input.delimiter)\n                if self.input.delimiter\n                else [swap.output_key]\n            )\n\n            body, value = self.find(body, key_parts)\n            body = self.add(body, output_key_parts, value)\n\n        return body\n</code></pre>"},{"location":"regex_rename/#extraction_methods.plugins.regex_rename.RegexRenameExtract.add","title":"<code>add(body, key_parts, value)</code>","text":"<p>Rename terms</p> <p>:param body: current body :type body: dict :param key_parts: key parts seperated by delimiter :type key_parts: list</p> <p>:return: dict :rtype: update body</p> Source code in <code>extraction_methods/plugins/regex_rename.py</code> <pre><code>def add(\n    self, body: dict[str, Any], key_parts: list[str], value: Any\n) -&gt; dict[str, Any]:\n    \"\"\"\n    Rename terms\n\n    :param body: current body\n    :type body: dict\n    :param key_parts: key parts seperated by delimiter\n    :type key_parts: list\n\n    :return: dict\n    :rtype: update body\n    \"\"\"\n    if len(key_parts) &gt; 1:\n        body[key_parts[0]] = self.add(body[key_parts[0]], key_parts[1:], value)\n\n    else:\n        body[key_parts[0]] = value\n\n    return body\n</code></pre>"},{"location":"regex_rename/#extraction_methods.plugins.regex_rename.RegexRenameExtract.find","title":"<code>find(body, key_parts)</code>","text":"<p>Rename terms</p> <p>:param body: current body :type body: dict :param key_parts: key parts seperated by delimiter :type key_parts: list</p> <p>:return: dict :rtype: update body</p> Source code in <code>extraction_methods/plugins/regex_rename.py</code> <pre><code>def find(\n    self, body: dict[str, Any], key_parts: list[str]\n) -&gt; tuple[dict[str, Any], Any]:\n    \"\"\"\n    Rename terms\n\n    :param body: current body\n    :type body: dict\n    :param key_parts: key parts seperated by delimiter\n    :type key_parts: list\n\n    :return: dict\n    :rtype: update body\n    \"\"\"\n    value = None\n    for key in self.matching_keys(body.keys(), key_parts[0]):\n        if len(key_parts) &gt; 1:\n            body[key], value = self.find(body[key], key_parts[1:])\n\n        else:\n            value = body[key]\n            del body[key]\n\n    return body, value\n</code></pre>"},{"location":"regex_rename/#extraction_methods.plugins.regex_rename.RegexRenameExtract.matching_keys","title":"<code>matching_keys(keys, key_regex)</code>","text":"<p>Find all keys that match regex</p> <p>:param keys: dictionary keys to test :type keys: KeysView :param key_regex: regex to test against :type key_regex: str</p> <p>:return: matching keys :rtype: list</p> Source code in <code>extraction_methods/plugins/regex_rename.py</code> <pre><code>def matching_keys(self, keys: KeysView[str], key_regex: str) -&gt; list[str]:\n    \"\"\"\n    Find all keys that match regex\n\n    :param keys: dictionary keys to test\n    :type keys: KeysView\n    :param key_regex: regex to test against\n    :type key_regex: str\n\n    :return: matching keys\n    :rtype: list\n    \"\"\"\n\n    regex = re.compile(key_regex)\n\n    return list(filter(regex.match, keys))\n</code></pre>"},{"location":"regex_rename/#extraction_methods.plugins.regex_rename.RegexRenameInput","title":"<code>RegexRenameInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for Regex Rename Input.</p> <p>Parameters:</p> Name Type Description Default <code>regex_swaps</code> <code>list[RegexOutputKey]</code> <p>Regex and output key combinations.</p> required <code>delimiter</code> <code>str</code> <p>delimiter for nested term.</p> <code>''</code> Source code in <code>extraction_methods/plugins/regex_rename.py</code> <pre><code>class RegexRenameInput(Input):\n    \"\"\"\n    Model for Regex Rename Input.\n    \"\"\"\n\n    regex_swaps: list[RegexOutputKey] = Field(\n        description=\"Regex and output key combinations.\",\n    )\n    delimiter: str = Field(\n        default=\"\",\n        description=\"delimiter for nested term.\",\n    )\n</code></pre>"},{"location":"regex_type_cast/","title":"Regex type cast","text":""},{"location":"regex_type_cast/#extraction_methods.plugins.regex_type_cast.RegexCastType","title":"<code>RegexCastType</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for Regex Cast Type.</p> <p>Parameters:</p> Name Type Description Default <code>regex</code> <code>str</code> <p>Regex to test against.</p> required <code>cast_type</code> <code>str</code> <p>Python type to cast to.</p> required Source code in <code>extraction_methods/plugins/regex_type_cast.py</code> <pre><code>class RegexCastType(Input):\n    \"\"\"\n    Model for Regex Cast Type.\n    \"\"\"\n\n    regex: str = Field(\n        description=\"Regex to test against.\",\n    )\n    cast_type: str = Field(\n        description=\"Python type to cast to.\",\n    )\n</code></pre>"},{"location":"regex_type_cast/#extraction_methods.plugins.regex_type_cast.RegexTypeCastExtract","title":"<code>RegexTypeCastExtract</code>","text":"<p>               Bases: <code>ExtractionMethod</code></p> <p>Method name: <code>regex_type_cast</code></p> <p>Takes a list of regex and cast type combinations. Any existing properties that full match a regex are cast to the associated type.</p> Example configuration <p>.. code-block:: yaml</p> <pre><code>- method: regex_type_cast\n  inputs:\n    regex_casts:\n      - regex: clound_cover\n        cast_type: int\n</code></pre>"},{"location":"regex_type_cast/#extraction_methods.plugins.regex_type_cast.RegexTypeCastExtract--noqa-w605","title":"noqa: W605","text":"Source code in <code>extraction_methods/plugins/regex_type_cast.py</code> <pre><code>class RegexTypeCastExtract(ExtractionMethod):\n    \"\"\"\n    **Method name:** ``regex_type_cast``\n\n    Takes a list of regex and cast type combinations. Any existing properties\n    that full match a regex are cast to the associated type.\n\n    Example configuration:\n        .. code-block:: yaml\n\n            - method: regex_type_cast\n              inputs:\n                regex_casts:\n                  - regex: clound_cover\n                    cast_type: int\n\n    # noqa: W605\n    \"\"\"\n\n    input_class = RegexTypeCastInput\n\n    @update_input\n    def run(self, body: dict[str, Any]) -&gt; dict[str, Any]:\n\n        output = body.copy()\n        for key in body.keys():\n            for regex_cast in self.input.regex_casts:\n                if re.fullmatch(rf\"{regex_cast.regex}\", key):\n                    cast_type = ast.literal_eval(regex_cast.cast_type)\n                    output[key] = cast_type(body[key])\n\n        return output\n</code></pre>"},{"location":"regex_type_cast/#extraction_methods.plugins.regex_type_cast.RegexTypeCastInput","title":"<code>RegexTypeCastInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for Regex Cast Type Input.</p> <p>Parameters:</p> Name Type Description Default <code>regex_casts</code> <code>list[RegexCastType]</code> <p>Regex and cast type combinations.</p> required Source code in <code>extraction_methods/plugins/regex_type_cast.py</code> <pre><code>class RegexTypeCastInput(Input):\n    \"\"\"\n    Model for Regex Cast Type Input.\n    \"\"\"\n\n    regex_casts: list[RegexCastType] = Field(\n        description=\"Regex and cast type combinations.\",\n    )\n</code></pre>"},{"location":"remove/","title":"Remove","text":""},{"location":"remove/#extraction_methods.plugins.remove.RemoveExtract","title":"<code>RemoveExtract</code>","text":"<p>               Bases: <code>ExtractionMethod</code></p> <p>Method name: <code>remove</code></p> <p>remove keys from body.</p> Example Configuration <p>.. code-block:: yaml</p> <pre><code>- method: remove\n  inputs:\n    keys:\n      - hello\n      - world\n</code></pre> Source code in <code>extraction_methods/plugins/remove.py</code> <pre><code>class RemoveExtract(ExtractionMethod):\n    \"\"\"\n    **Method name:** ``remove``\n\n    remove keys from body.\n\n    Example Configuration:\n        .. code-block:: yaml\n\n            - method: remove\n              inputs:\n                keys:\n                  - hello\n                  - world\n    \"\"\"\n\n    input_class = RemoveInput\n\n    def matching_keys(self, keys: KeysView[str], key_regex: str) -&gt; list[str]:\n        \"\"\"\n        Find all keys that match regex\n\n        :param keys: dictionary keys to test\n        :type keys: KeysView\n        :param key_regex: regex to test against\n        :type key_regex: str\n\n        :return: matching keys\n        :rtype: list\n        \"\"\"\n\n        regex = re.compile(key_regex)\n\n        return list(filter(regex.match, keys))\n\n    def remove_key(self, body: dict[str, Any], key_parts: list[str]) -&gt; dict[str, Any]:\n        \"\"\"\n        Remove nested terms\n\n        :param body: current body\n        :type body: dict\n        :param key_parts: key parts seperated by delimiter\n        :type key_parts: list\n\n        :return: dict\n        :rtype: update body\n        \"\"\"\n\n        for key in self.matching_keys(body.keys(), key_parts[0]):\n\n            if len(key_parts) &gt; 1:\n                body[key] = self.remove_key(body[key], key_parts[1:])\n\n            else:\n                del body[key]\n\n        return body\n\n    @update_input\n    def run(self, body: dict[str, Any]) -&gt; dict[str, Any]:\n\n        for key in self.input.keys:\n            body = self.remove_key(body, key.split(self.input.delimiter))\n\n        return body\n</code></pre>"},{"location":"remove/#extraction_methods.plugins.remove.RemoveExtract.matching_keys","title":"<code>matching_keys(keys, key_regex)</code>","text":"<p>Find all keys that match regex</p> <p>:param keys: dictionary keys to test :type keys: KeysView :param key_regex: regex to test against :type key_regex: str</p> <p>:return: matching keys :rtype: list</p> Source code in <code>extraction_methods/plugins/remove.py</code> <pre><code>def matching_keys(self, keys: KeysView[str], key_regex: str) -&gt; list[str]:\n    \"\"\"\n    Find all keys that match regex\n\n    :param keys: dictionary keys to test\n    :type keys: KeysView\n    :param key_regex: regex to test against\n    :type key_regex: str\n\n    :return: matching keys\n    :rtype: list\n    \"\"\"\n\n    regex = re.compile(key_regex)\n\n    return list(filter(regex.match, keys))\n</code></pre>"},{"location":"remove/#extraction_methods.plugins.remove.RemoveExtract.remove_key","title":"<code>remove_key(body, key_parts)</code>","text":"<p>Remove nested terms</p> <p>:param body: current body :type body: dict :param key_parts: key parts seperated by delimiter :type key_parts: list</p> <p>:return: dict :rtype: update body</p> Source code in <code>extraction_methods/plugins/remove.py</code> <pre><code>def remove_key(self, body: dict[str, Any], key_parts: list[str]) -&gt; dict[str, Any]:\n    \"\"\"\n    Remove nested terms\n\n    :param body: current body\n    :type body: dict\n    :param key_parts: key parts seperated by delimiter\n    :type key_parts: list\n\n    :return: dict\n    :rtype: update body\n    \"\"\"\n\n    for key in self.matching_keys(body.keys(), key_parts[0]):\n\n        if len(key_parts) &gt; 1:\n            body[key] = self.remove_key(body[key], key_parts[1:])\n\n        else:\n            del body[key]\n\n    return body\n</code></pre>"},{"location":"remove/#extraction_methods.plugins.remove.RemoveInput","title":"<code>RemoveInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for Remove Input.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>list[str]</code> <p>list of keys to remove.</p> required <code>delimiter</code> <code>str</code> <p>delimiter for nested term.</p> <code>'.'</code> Source code in <code>extraction_methods/plugins/remove.py</code> <pre><code>class RemoveInput(Input):\n    \"\"\"\n    Model for Remove Input.\n    \"\"\"\n\n    keys: list[str] = Field(\n        description=\"list of keys to remove.\",\n    )\n    delimiter: str = Field(\n        default=\".\",\n        description=\"delimiter for nested term.\",\n    )\n</code></pre>"},{"location":"stac_extension/","title":"Stac extension","text":""},{"location":"stac_extension/#extraction_methods.plugins.stac_extension.STACExtension","title":"<code>STACExtension</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for STAC Extension.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Extension URL.</p> required <code>prefix</code> <code>str</code> <p>Extension prefix.</p> required <code>properties</code> <code>list[str]</code> <p>Extension properties.</p> required Source code in <code>extraction_methods/plugins/stac_extension.py</code> <pre><code>class STACExtension(BaseModel):\n    \"\"\"\n    Model for STAC Extension.\n    \"\"\"\n\n    url: str = Field(\n        description=\"Extension URL.\",\n    )\n    prefix: str = Field(\n        description=\"Extension prefix.\",\n    )\n    properties: list[str] = Field(\n        description=\"Extension properties.\",\n    )\n</code></pre>"},{"location":"stac_extension/#extraction_methods.plugins.stac_extension.STACExtensionExtract","title":"<code>STACExtensionExtract</code>","text":"<p>               Bases: <code>ExtractionMethod</code></p> <p>Method name: <code>stac_extension</code></p> <p>Accepts a list of extensions which contain url, prefix and list of properties.</p> Example Configuration <p>.. code-block:: yaml</p> <pre><code>- method: stac_extension\n  inputs:\n    extensions:\n      - url: hello.com/v1.0.0/world.json\n        prefix: hello\n        properties:\n          - foo\n          - bar\n</code></pre> Source code in <code>extraction_methods/plugins/stac_extension.py</code> <pre><code>class STACExtensionExtract(ExtractionMethod):\n    \"\"\"\n    **Method name:** ``stac_extension``\n\n    Accepts a list of extensions which contain url, prefix and\n    list of properties.\n\n    Example Configuration:\n        .. code-block:: yaml\n\n            - method: stac_extension\n              inputs:\n                extensions:\n                  - url: hello.com/v1.0.0/world.json\n                    prefix: hello\n                    properties:\n                      - foo\n                      - bar\n    \"\"\"\n\n    input_class = STACExtensionInput\n\n    @update_input\n    def run(self, body: dict[str, Any]) -&gt; dict[str, Any]:\n\n        extension_urls = []\n        for extension in self.input.extensions:\n            extension_urls.append(extension.url)\n            for property_name in extension.properties:\n                if property_name in body:\n                    body[f\"{extension.prefix}:{property_name}\"] = body.pop(\n                        property_name\n                    )\n\n        body[\"stac_extensions\"] = body.get(\"stac_extensions\", []) + extension_urls\n\n        return body\n</code></pre>"},{"location":"stac_extension/#extraction_methods.plugins.stac_extension.STACExtensionInput","title":"<code>STACExtensionInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for STAC Extension Input.</p> <p>Parameters:</p> Name Type Description Default <code>extensions</code> <code>list[STACExtension]</code> <p>List of extensions.</p> required Source code in <code>extraction_methods/plugins/stac_extension.py</code> <pre><code>class STACExtensionInput(Input):\n    \"\"\"\n    Model for STAC Extension Input.\n    \"\"\"\n\n    extensions: list[STACExtension] = Field(\n        description=\"List of extensions.\",\n    )\n</code></pre>"},{"location":"string_template/","title":"String template","text":""},{"location":"string_template/#extraction_methods.plugins.string_template.StringTemplateExtract","title":"<code>StringTemplateExtract</code>","text":"<p>               Bases: <code>ExtractionMethod</code></p> <p>Method name: <code>string_template</code></p> <p>Accepts a template and output_key. terms are added to the template.</p> Example Configuration <p>.. code-block:: yaml</p> <pre><code>- method: string_template\n  inputs:\n    template: {hello}/{goodbye}/{hello}/bonjour.html\n    output_key: manifest_url\n</code></pre> Source code in <code>extraction_methods/plugins/string_template.py</code> <pre><code>class StringTemplateExtract(ExtractionMethod):\n    \"\"\"\n    **Method name:** ``string_template``\n\n    Accepts a template and output_key. terms are added to the template.\n\n    Example Configuration:\n        .. code-block:: yaml\n\n            - method: string_template\n              inputs:\n                template: {hello}/{goodbye}/{hello}/bonjour.html\n                output_key: manifest_url\n    \"\"\"\n\n    input_class = StringTemplateInput\n\n    @update_input\n    def run(self, body: dict[str, Any]) -&gt; dict[str, Any]:\n\n        terms = re.findall(\"{(.*?)}\", self.input.template)\n\n        if self.input.descructive:\n            format_terms = {term: body.pop(term, \"\") for term in terms}\n        else:\n            format_terms = {term: body.get(term, \"\") for term in terms}\n\n        body[self.input.output_key] = self.input.template.format(**format_terms)\n\n        return body\n</code></pre>"},{"location":"string_template/#extraction_methods.plugins.string_template.StringTemplateInput","title":"<code>StringTemplateInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for String Template Input.</p> <p>Parameters:</p> Name Type Description Default <code>template</code> <code>str</code> <p>Template to follow.</p> required <code>descructive</code> <code>bool</code> <p>True if terms should be removed after templating.</p> <code>False</code> <code>output_key</code> <code>str</code> <p>key to output to.</p> required Source code in <code>extraction_methods/plugins/string_template.py</code> <pre><code>class StringTemplateInput(Input):\n    \"\"\"\n    Model for String Template Input.\n    \"\"\"\n\n    template: str = Field(\n        description=\"Template to follow.\",\n    )\n    descructive: bool = Field(\n        default=False,\n        description=\"True if terms should be removed after templating.\",\n    )\n    output_key: str = Field(\n        description=\"key to output to.\",\n    )\n</code></pre>"},{"location":"xml/","title":"Xml","text":""},{"location":"xml/#extraction_methods.plugins.xml.XMLExtract","title":"<code>XMLExtract</code>","text":"<p>               Bases: <code>ExtractionMethod</code></p> <p>Method name: <code>xml</code></p> <p>Processes XML documents to extract metadata</p> Example configuration <p>.. code-block:: yaml</p> <pre><code>- method: xml\n  inputs:\n    properties:\n      - name: start_datetime\n        key: './/gml:beginPosition'\n        attribute: start\n</code></pre>"},{"location":"xml/#extraction_methods.plugins.xml.XMLExtract--noqa-w605","title":"noqa: W605","text":"Source code in <code>extraction_methods/plugins/xml.py</code> <pre><code>class XMLExtract(ExtractionMethod):\n    \"\"\"\n    **Method name:** ``xml``\n\n    Processes XML documents to extract metadata\n\n    Example configuration:\n        .. code-block:: yaml\n\n            - method: xml\n              inputs:\n                properties:\n                  - name: start_datetime\n                    key: './/gml:beginPosition'\n                    attribute: start\n\n    # noqa: W605\n    \"\"\"\n\n    input_class = XMLInput\n\n    def run(self, body: dict[str, Any]) -&gt; dict[str, Any]:\n\n        # Extract the keys\n        try:\n\n            if os.path.isfile(self.input.input_term):\n                xml_file = etree.parse(self.input.input_term)\n\n            else:\n                xml_file = etree.XML(self.input.input_term.encode(\"ascii\", \"ignore\"))\n\n        except (etree.ParseError, FileNotFoundError, TypeError):\n            return body\n\n        output: dict[str, list[str]] = defaultdict(list)\n\n        for prop in self.input.properties:\n            values = xml_file.findall(\n                prop.key,\n                self.input.namespaces,\n            )\n\n            for value in values:\n                if value is not None:\n\n                    if prop.attribute:\n                        v = value.get(prop.attribute, \"\")\n\n                    else:\n                        v = value.text\n\n                    if v and v not in output[prop.output_key]:\n                        output[prop.output_key].append(v.strip())\n\n            if output[prop.output_key]:\n                body[prop.output_key] = (\n                    output[prop.output_key][0]\n                    if len(output[prop.output_key]) == 1\n                    else output[prop.output_key]\n                )\n\n        return body\n</code></pre>"},{"location":"xml/#extraction_methods.plugins.xml.XMLInput","title":"<code>XMLInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for XML Input.</p> <p>Parameters:</p> Name Type Description Default <code>input_term</code> <code>str</code> <p>Term for method to run on.</p> <code>'$uri'</code> <code>properties</code> <code>list[XMLProperty]</code> <p>List of properties to retrieve from the document.</p> required <code>namespaces</code> <code>dict[str, str]</code> <p>Map of namespaces.</p> required Source code in <code>extraction_methods/plugins/xml.py</code> <pre><code>class XMLInput(Input):\n    \"\"\"\n    Model for XML Input.\n    \"\"\"\n\n    input_term: str = Field(\n        default=\"$uri\",\n        description=\"Term for method to run on.\",\n    )\n    # template: str = Field(\n    #     description=\"Template to follow.\",\n    # )\n    properties: list[XMLProperty] = Field(\n        description=\"List of properties to retrieve from the document.\",\n    )\n    # filter_expr: str = Field(\n    #     description=\"Regex to match against files to limit the attempts to known files.\",\n    # )\n    namespaces: dict[str, str] = Field(\n        description=\"Map of namespaces.\",\n    )\n</code></pre>"},{"location":"xml/#extraction_methods.plugins.xml.XMLProperty","title":"<code>XMLProperty</code>","text":"<p>               Bases: <code>KeyOutputKey</code></p> <p>Model for XML property.</p> <p>Parameters:</p> Name Type Description Default <code>attribute</code> <code>str</code> <p>Attribute of the XML property.</p> <code>''</code> Source code in <code>extraction_methods/plugins/xml.py</code> <pre><code>class XMLProperty(KeyOutputKey):\n    \"\"\"\n    Model for XML property.\n\n    \"\"\"\n\n    attribute: str = Field(\n        default=\"\",\n        description=\"Attribute of the XML property.\",\n    )\n</code></pre>"},{"location":"assets/assets/","title":"Assets","text":""},{"location":"assets/assets/#extraction_methods.plugins.assets.assets.AssetExtract","title":"<code>AssetExtract</code>","text":"<p>               Bases: <code>SetEntryPointsMixin</code>, <code>ExtractionMethod</code></p> <p>Method name: <code>assets</code></p> <p>Method to generate a dictionary of STAC Assets.</p> Example Configuration <p>.. code-block:: yaml</p> <pre><code>- method: assets\n  inputs:\n    backend:\n      name: elasticsearch\n      inputs:\n        connection_kwargs:\n          hosts: ['host1:9200','host2:9200']\n    extraction_methods:\n      - method: default\n        inputs:\n          defaults:\n            hello: world\n</code></pre> Source code in <code>extraction_methods/plugins/assets/assets.py</code> <pre><code>class AssetExtract(SetEntryPointsMixin, ExtractionMethod):\n    \"\"\"\n    **Method name:** ``assets``\n\n    Method to generate a dictionary of STAC Assets.\n\n\n    Example Configuration:\n        .. code-block:: yaml\n\n            - method: assets\n              inputs:\n                backend:\n                  name: elasticsearch\n                  inputs:\n                    connection_kwargs:\n                      hosts: ['host1:9200','host2:9200']\n                extraction_methods:\n                  - method: default\n                    inputs:\n                      defaults:\n                        hello: world\n    \"\"\"\n\n    input_class = AssetInput\n    entry_point_group: str = \"extraction_methods.assets.backends\"\n\n    @update_input\n    def run(self, body: dict[str, Any]) -&gt; dict[str, Any]:\n\n        output = {}\n        backend_entry_point = self.entry_points[self.input.backend.method].load()\n        backend = backend_entry_point(self.input.backend)\n        assets = backend._run(body)\n\n        for asset in assets:\n            for extraction_method in self.input.extraction_methods:\n                asset = extraction_method._run(asset)\n            output[asset[\"href\"]] = asset\n\n        body[self.input.output_key] = body.get(self.input.output_key, {}) | output\n\n        return body\n</code></pre>"},{"location":"assets/assets/#extraction_methods.plugins.assets.assets.AssetInput","title":"<code>AssetInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for Asset Method Input.</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>Backend</code> <p>Backend and inputs to run.</p> required <code>extraction_methods</code> <code>list[ExtractionMethodConf]</code> <p>Extraction methods to run on assets.</p> <code>[]</code> <code>output_key</code> <code>str</code> <p>term for method to output to.</p> <code>'assets'</code> Source code in <code>extraction_methods/plugins/assets/assets.py</code> <pre><code>class AssetInput(Input):\n    \"\"\"\n    Model for Asset Method Input.\n    \"\"\"\n\n    backend: Backend = Field(\n        description=\"Backend and inputs to run.\",\n    )\n    extraction_methods: list[ExtractionMethodConf] = Field(\n        default=[],\n        description=\"Extraction methods to run on assets.\",\n    )\n    output_key: str = Field(\n        default=\"assets\",\n        description=\"term for method to output to.\",\n    )\n</code></pre>"},{"location":"assets/backends/elasticsearch/","title":"Elasticsearch","text":""},{"location":"assets/backends/elasticsearch/#extraction_methods.plugins.assets.backends.elasticsearch.ElasticsearchAssets","title":"<code>ElasticsearchAssets</code>","text":"<p>               Bases: <code>Backend</code></p> <p>Method name: <code>elasticsearch_assets</code></p> <p>Using an ID. Generate a summary of information for higher level entities.</p> Example Configuration <p>.. code-block:: yaml</p> <pre><code>- name: elasticsearch\n  inputs:\n    index: ceda-index\n    id_term: item_id\n    client_kwargs:\n        hosts: ['host1:9200','host2:9200']\n    fields:\n        - roles\n</code></pre> Source code in <code>extraction_methods/plugins/assets/backends/elasticsearch.py</code> <pre><code>class ElasticsearchAssets(Backend):\n    \"\"\"\n    **Method name:** ``elasticsearch_assets``\n\n    Using an ID. Generate a summary of information for higher level entities.\n\n\n    Example Configuration:\n        .. code-block:: yaml\n\n            - name: elasticsearch\n              inputs:\n                index: ceda-index\n                id_term: item_id\n                client_kwargs:\n                    hosts: ['host1:9200','host2:9200']\n                fields:\n                    - roles\n    \"\"\"\n\n    input_class = ElasticsearchAssetsInput\n\n    @update_input\n    def run(self, body: dict[str, Any]) -&gt; Iterator[dict[str, Any]]:\n\n        es = Elasticsearch_client(**self.input.client_kwargs)\n\n        # Run search\n        result = es.search(\n            index=self.input.index,\n            body=self.input.body,\n            timeout=f\"{self.input.request_timeout}s\",\n        )\n\n        for hit in result[\"hits\"][\"hits\"]:\n            source = hit[\"_source\"]\n            source[\"href\"] = source.pop(self.input.href_term)\n\n            yield source\n</code></pre>"},{"location":"assets/backends/elasticsearch/#extraction_methods.plugins.assets.backends.elasticsearch.ElasticsearchAssetsInput","title":"<code>ElasticsearchAssetsInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for Elasticsearch Assets Backend Input.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>str</code> <p>Elasticsearch index to search on.</p> required <code>client_kwargs</code> <code>dict[str, Any]</code> <p>Elasticsearch connection kwargs.</p> <code>{}</code> <code>request_timeout</code> <code>int</code> <p>Request timeout for search.</p> <code>60</code> <code>body</code> <code>dict[str, Any]</code> <p>Body for Elasticsearch search request.</p> required <code>href_term</code> <code>str</code> <p>term to use for href.</p> <code>'path'</code> Source code in <code>extraction_methods/plugins/assets/backends/elasticsearch.py</code> <pre><code>class ElasticsearchAssetsInput(Input):\n    \"\"\"\n    Model for Elasticsearch Assets Backend Input.\n    \"\"\"\n\n    index: str = Field(\n        description=\"Elasticsearch index to search on.\",\n    )\n    client_kwargs: dict[str, Any] = Field(\n        default={},\n        description=\"Elasticsearch connection kwargs.\",\n    )\n    request_timeout: int = Field(\n        default=60,\n        description=\"Request timeout for search.\",\n    )\n    body: dict[str, Any] = Field(\n        description=\"Body for Elasticsearch search request.\",\n    )\n    href_term: str = Field(\n        default=\"path\",\n        description=\"term to use for href.\",\n    )\n</code></pre>"},{"location":"assets/backends/intake_esm/","title":"Intake esm","text":""},{"location":"assets/backends/intake_esm/#extraction_methods.plugins.assets.backends.intake_esm.IntakeESMAssets","title":"<code>IntakeESMAssets</code>","text":"<p>               Bases: <code>Backend</code></p> <p>Method name: <code>intake_assets</code></p> <p>Performs Search on intake catalog to provide a stream of assets for procesing. Uses an <code>Intake catalog &lt;https://intake.readthedocs.io/&gt;</code>_ as a source for file objects.</p> Example Configuration <p>.. code-block:: yaml</p> <ul> <li>method: intake_esm   inputs:     href_term: url</li> </ul> Source code in <code>extraction_methods/plugins/assets/backends/intake_esm.py</code> <pre><code>class IntakeESMAssets(Backend):\n    \"\"\"\n    **Method name:** ``intake_assets``\n\n    Performs Search on intake catalog to provide a stream of assets for procesing.\n    Uses an `Intake catalog &lt;https://intake.readthedocs.io/&gt;`_\n    as a source for file objects.\n\n    Example Configuration:\n        .. code-block:: yaml\n\n        - method: intake_esm\n          inputs:\n            href_term: url\n    \"\"\"\n\n    input_class = IntakeESMAssetsInput\n\n    @update_input\n    def run(self, body: dict[str, Any]) -&gt; Iterator[dict[str, Any]]:\n\n        catalog = intake.open_esm_datastore(\n            self.input.input_term, **self.input.datastore_kwargs\n        )\n\n        if search_kwargs := self.input.search_kwargs:\n            catalog = catalog.search(**search_kwargs)\n\n        for _, row in catalog.df.iterrows():\n            if href := getattr(row, self.input.href_term):\n                yield {\n                    \"href\": href,\n                }\n</code></pre>"},{"location":"assets/backends/intake_esm/#extraction_methods.plugins.assets.backends.intake_esm.IntakeESMAssetsInput","title":"<code>IntakeESMAssetsInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for IntakeESM Assets Backend Input.</p> <p>Parameters:</p> Name Type Description Default <code>input_term</code> <code>str</code> <p>term for method to run on.</p> <code>'$uri'</code> <code>href_term</code> <code>str</code> <p>term to use for href.</p> <code>'path'</code> <code>datastore_kwargs</code> <code>dict[str, Any]</code> <p>kwargs to open datastore.</p> <code>{}</code> <code>search_kwargs</code> <code>dict[str, Any]</code> <p>kwargs for search.</p> <code>{}</code> Source code in <code>extraction_methods/plugins/assets/backends/intake_esm.py</code> <pre><code>class IntakeESMAssetsInput(Input):\n    \"\"\"\n    Model for IntakeESM Assets Backend Input.\n    \"\"\"\n\n    input_term: str = Field(\n        default=\"$uri\",\n        description=\"term for method to run on.\",\n    )\n    href_term: str = Field(\n        default=\"path\",\n        description=\"term to use for href.\",\n    )\n    datastore_kwargs: dict[str, Any] = Field(\n        default={},\n        description=\"kwargs to open datastore.\",\n    )\n    search_kwargs: dict[str, Any] = Field(\n        default={},\n        description=\"kwargs for search.\",\n    )\n</code></pre>"},{"location":"assets/backends/regex/","title":"Regex","text":""},{"location":"assets/backends/regex/#extraction_methods.plugins.assets.backends.regex.RegexAssets","title":"<code>RegexAssets</code>","text":"<p>               Bases: <code>Backend</code></p> <p>Method name: <code>regex_assets</code></p> <p>Takes a regex glob and yields a dictionary for each matching path.</p> Example configuration <p>.. code-block:: yaml</p> <ul> <li>method: regex   inputs:     input_term: ^(?:[^_]_){2}(?P\\d)"},{"location":"assets/backends/regex/#extraction_methods.plugins.assets.backends.regex.RegexAssets--noqa-w605","title":"noqa: W605","text":"Source code in <code>extraction_methods/plugins/assets/backends/regex.py</code> <pre><code>class RegexAssets(Backend):\n    \"\"\"\n    **Method name:** ``regex_assets``\n\n    Takes a regex glob and yields a dictionary for each matching path.\n\n    Example configuration:\n        .. code-block:: yaml\n\n        - method: regex\n          inputs:\n            input_term: ^(?:[^_]*_){2}(?P&lt;datetime&gt;\\d*)\n\n    # noqa: W605\n    \"\"\"\n\n    input_class = RegexAssetsInput\n\n    @update_input\n    def run(self, body: dict[str, Any]) -&gt; Iterator[dict[str, Any]]:\n\n        for path in glob.iglob(self.input.input_term):\n            yield {\n                \"href\": path,\n            }\n</code></pre>"},{"location":"assets/backends/regex/#extraction_methods.plugins.assets.backends.regex.RegexAssetsInput","title":"<code>RegexAssetsInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for Regex Assets Backend Input.</p> <p>Parameters:</p> Name Type Description Default <code>input_term</code> <code>str</code> <p>term for method to run on.</p> <code>'$uri'</code> Source code in <code>extraction_methods/plugins/assets/backends/regex.py</code> <pre><code>class RegexAssetsInput(Input):\n    \"\"\"\n    Model for Regex Assets Backend Input.\n    \"\"\"\n\n    input_term: str = Field(\n        default=\"$uri\",\n        description=\"term for method to run on.\",\n    )\n</code></pre>"},{"location":"header/header/","title":"Header","text":""},{"location":"header/header/#extraction_methods.plugins.header.header.HeaderExtract","title":"<code>HeaderExtract</code>","text":"<p>               Bases: <code>ExtractionMethod</code>, <code>SetEntryPointsMixin</code></p> <p>Method name: <code>header</code></p> <p>Takes a header backend to run and returns the updated body from the configured backend.</p> Example configuration <p>.. code-block:: yaml</p> <ul> <li>method: header   inputs:     backend:         name: xarray         inputs:           kwargs:             decode_times: False           attributes:             - name: institution             - name: sensor</li> </ul> Source code in <code>extraction_methods/plugins/header/header.py</code> <pre><code>class HeaderExtract(ExtractionMethod, SetEntryPointsMixin):\n    \"\"\"\n    **Method name:** ``header``\n\n    Takes a header backend to run and returns the updated body\n    from the configured backend.\n\n    Example configuration:\n        .. code-block:: yaml\n\n        - method: header\n          inputs:\n            backend:\n                name: xarray\n                inputs:\n                  kwargs:\n                    decode_times: False\n                  attributes:\n                    - name: institution\n                    - name: sensor\n    \"\"\"\n\n    input_class = HeaderInput\n    entry_point_group = \"extraction_methods.header.backends\"\n\n    @update_input\n    def run(self, body: dict[str, Any]) -&gt; dict[str, Any]:\n\n        backend_entry_point = self.entry_points[self.input.backend.name].load()\n        backend = backend_entry_point(**self.input.backend.inputs)\n        body = backend._run(body)\n\n        return body\n</code></pre>"},{"location":"header/header/#extraction_methods.plugins.header.header.HeaderInput","title":"<code>HeaderInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for Header Method Input.</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>Backend</code> <p>Backend and inputs to run.</p> required Source code in <code>extraction_methods/plugins/header/header.py</code> <pre><code>class HeaderInput(Input):\n    \"\"\"\n    Model for Header Method Input.\n    \"\"\"\n\n    backend: Backend = Field(\n        description=\"Backend and inputs to run.\",\n    )\n</code></pre>"},{"location":"header/backends/cf/","title":"Cf","text":""},{"location":"header/backends/cf/#extraction_methods.plugins.header.backends.cf.CfHeader","title":"<code>CfHeader</code>","text":"<p>               Bases: <code>ExtractionMethod</code></p> <p>Method name: <code>cf</code></p> <p>CF backend for header method.</p> Example configuration <p>.. code-block:: yaml</p> <ul> <li>method: cf   inputs:     input_term: hello_world</li> </ul> Source code in <code>extraction_methods/plugins/header/backends/cf.py</code> <pre><code>class CfHeader(ExtractionMethod):\n    \"\"\"\n    **Method name:** ``cf``\n\n    CF backend for header method.\n\n    Example configuration:\n        .. code-block:: yaml\n\n        - method: cf\n          inputs:\n            input_term: hello_world\n    \"\"\"\n\n    input_class = CfHeaderInput\n\n    @update_input\n    def run(self, body: dict[str, Any]) -&gt; dict[str, Any]:\n        field_list = cf.read(self.input.input_term, **self.input.read_kwargs)\n\n        properties: dict[str, Any] = {}\n        for field in field_list:\n            properties |= field.properties()\n            if field.nc_global_attributes():\n                properties[\"global_attributes\"] = field.nc_global_attributes()\n\n        for attribute in self.input.attributes:\n            if (\n                \"global_attributes\" in properties\n                and properties[\"global_attributes\"][attribute.key]\n            ):\n                body[attribute.output_key] = properties[\"global_attributes\"][\n                    attribute.key\n                ]\n            elif attribute in properties:\n                body[attribute.output_key] = properties[attribute.key]\n\n        return body\n</code></pre>"},{"location":"header/backends/cf/#extraction_methods.plugins.header.backends.cf.CfHeaderInput","title":"<code>CfHeaderInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for CF Header Input.</p> Source code in <code>extraction_methods/plugins/header/backends/cf.py</code> <pre><code>class CfHeaderInput(Input):\n    \"\"\"\n    Model for CF Header Input.\n    \"\"\"\n\n    input_term: str = Field(\n        default=\"$uri\",\n        description=\"term for method to run on.\",\n    )\n    read_kwargs: dict[str, Any] = Field(\n        default={},\n        description=\"kwargs for cf read.\",\n    )\n    attributes: list[KeyOutputKey] = Field(\n        default=[],\n        description=\"attributes to be extracted.\",\n    )\n</code></pre>"},{"location":"header/backends/ncml/","title":"Ncml","text":""},{"location":"header/backends/ncml/#extraction_methods.plugins.header.backends.ncml.NcMLHeader","title":"<code>NcMLHeader</code>","text":"<p>               Bases: <code>ExtractionMethod</code></p> <p>Method name: <code>ncml</code></p> <p>NcML backend for header method.</p> Example configuration <p>.. code-block:: yaml</p> <ul> <li>method: ncml   inputs:     input_term: hello_world</li> </ul> Source code in <code>extraction_methods/plugins/header/backends/ncml.py</code> <pre><code>class NcMLHeader(ExtractionMethod):\n    \"\"\"\n    **Method name:** ``ncml``\n\n    NcML backend for header method.\n\n    Example configuration:\n        .. code-block:: yaml\n\n        - method: ncml\n          inputs:\n            input_term: hello_world\n    \"\"\"\n\n    input_class = NcMLHeaderInput\n\n    def get_ncml(self) -&gt; bytes:\n        \"\"\"Get the NcML file description.\"\"\"\n\n        parse_result = urlparse(self.input.input_term)\n\n        if parse_result.netloc:\n            return self.get_ncml_from_thredds()\n\n        return self.get_ncml_from_fs()\n\n    def get_ncml_from_thredds(self) -&gt; bytes:\n        \"\"\"Read NcML response from THREDDS server.\n\n        Returns\n        -------\n        bytes\n        NcML content\n        \"\"\"\n\n        r = httpx.get(\n            self.input.input_term,\n            params=self.input.request_params,\n            timeout=self.input.request_timeout,\n        )\n        r.raise_for_status()\n        return r.content\n\n    def get_ncml_from_fs(self) -&gt; bytes:\n        \"\"\"Return NcML file description using `ncdump` utility.\"\"\"\n\n        cmd = [\"ncdump\", \"-hx\", self.input.input_term]\n        proc = subprocess.Popen(\n            cmd, stderr=subprocess.PIPE, stdout=subprocess.PIPE\n        )  # nosec B603\n        if proc.stdout:\n            return proc.stdout.read()\n        else:\n            return b\"\"\n\n    @update_input\n    def run(self, body: dict[str, Any]) -&gt; dict[str, Any]:\n        # Convert response to an XML etree.Element\n        content = self.get_ncml()\n        elemement = fromstring(\n            content, parser=XMLParser(encoding=\"UTF-8\")\n        )  # nosec B320\n\n        for attribute in self.input.attributes:\n\n            # Execute xpath expression\n            value = elemement.xpath(attribute.key, namespaces=self.input.namespaces)\n\n            if value:\n                body[attribute.output_key] = value[0]\n\n        return body\n</code></pre>"},{"location":"header/backends/ncml/#extraction_methods.plugins.header.backends.ncml.NcMLHeader.get_ncml","title":"<code>get_ncml()</code>","text":"<p>Get the NcML file description.</p> Source code in <code>extraction_methods/plugins/header/backends/ncml.py</code> <pre><code>def get_ncml(self) -&gt; bytes:\n    \"\"\"Get the NcML file description.\"\"\"\n\n    parse_result = urlparse(self.input.input_term)\n\n    if parse_result.netloc:\n        return self.get_ncml_from_thredds()\n\n    return self.get_ncml_from_fs()\n</code></pre>"},{"location":"header/backends/ncml/#extraction_methods.plugins.header.backends.ncml.NcMLHeader.get_ncml_from_fs","title":"<code>get_ncml_from_fs()</code>","text":"<p>Return NcML file description using <code>ncdump</code> utility.</p> Source code in <code>extraction_methods/plugins/header/backends/ncml.py</code> <pre><code>def get_ncml_from_fs(self) -&gt; bytes:\n    \"\"\"Return NcML file description using `ncdump` utility.\"\"\"\n\n    cmd = [\"ncdump\", \"-hx\", self.input.input_term]\n    proc = subprocess.Popen(\n        cmd, stderr=subprocess.PIPE, stdout=subprocess.PIPE\n    )  # nosec B603\n    if proc.stdout:\n        return proc.stdout.read()\n    else:\n        return b\"\"\n</code></pre>"},{"location":"header/backends/ncml/#extraction_methods.plugins.header.backends.ncml.NcMLHeader.get_ncml_from_thredds","title":"<code>get_ncml_from_thredds()</code>","text":"<p>Read NcML response from THREDDS server.</p>"},{"location":"header/backends/ncml/#extraction_methods.plugins.header.backends.ncml.NcMLHeader.get_ncml_from_thredds--returns","title":"Returns","text":"<p>bytes NcML content</p> Source code in <code>extraction_methods/plugins/header/backends/ncml.py</code> <pre><code>def get_ncml_from_thredds(self) -&gt; bytes:\n    \"\"\"Read NcML response from THREDDS server.\n\n    Returns\n    -------\n    bytes\n    NcML content\n    \"\"\"\n\n    r = httpx.get(\n        self.input.input_term,\n        params=self.input.request_params,\n        timeout=self.input.request_timeout,\n    )\n    r.raise_for_status()\n    return r.content\n</code></pre>"},{"location":"header/backends/ncml/#extraction_methods.plugins.header.backends.ncml.NcMLHeaderInput","title":"<code>NcMLHeaderInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for NcML Header Input.</p> <p>Parameters:</p> Name Type Description Default <code>input_term</code> <code>str</code> <p>term for method to run on.</p> <code>'$uri'</code> <code>request_params</code> <code>dict[str, Any]</code> <p>params for request.</p> <code>{'catalog': None, 'dataset': None}</code> <code>namespaces</code> <code>dict[str, str]</code> <p>NcML namespaces.</p> <code>{'ncml': 'http://www.unidata.ucar.edu/namespaces/netcdf/ncml-2.2'}</code> <code>attributes</code> <code>list[KeyOutputKey]</code> <p>attributes to be extracted.</p> <code>[]</code> <code>request_timeout</code> <code>int</code> <p>request time out.</p> <code>15</code> Source code in <code>extraction_methods/plugins/header/backends/ncml.py</code> <pre><code>class NcMLHeaderInput(Input):\n    \"\"\"\n    Model for NcML Header Input.\n    \"\"\"\n\n    input_term: str = Field(\n        default=\"$uri\",\n        description=\"term for method to run on.\",\n    )\n    request_params: dict[str, Any] = Field(\n        default={\"catalog\": None, \"dataset\": None},\n        description=\"params for request.\",\n    )\n    namespaces: dict[str, str] = Field(\n        default={\"ncml\": \"http://www.unidata.ucar.edu/namespaces/netcdf/ncml-2.2\"},\n        description=\"NcML namespaces.\",\n    )\n    attributes: list[KeyOutputKey] = Field(\n        default=[],\n        description=\"attributes to be extracted.\",\n    )\n    request_timeout: int = Field(\n        default=15,\n        description=\"request time out.\",\n    )\n</code></pre>"},{"location":"header/backends/xarray/","title":"Xarray","text":""},{"location":"header/backends/xarray/#extraction_methods.plugins.header.backends.xarray.XarrayHeader","title":"<code>XarrayHeader</code>","text":"<p>               Bases: <code>ExtractionMethod</code></p> <p>Method name: <code>xarray</code></p> <p>Xarray backend for header method.</p> Example configuration <p>.. code-block:: yaml</p> <ul> <li>method: xarray   inputs:     input_term: hello_world</li> </ul> Source code in <code>extraction_methods/plugins/header/backends/xarray.py</code> <pre><code>class XarrayHeader(ExtractionMethod):\n    \"\"\"\n    **Method name:** ``xarray``\n\n    Xarray backend for header method.\n\n    Example configuration:\n        .. code-block:: yaml\n\n        - method: xarray\n          inputs:\n            input_term: hello_world\n    \"\"\"\n\n    input_class = XarrayHeaderInput\n\n    @update_input\n    def run(self, body: dict[str, Any]) -&gt; dict[str, Any]:\n\n        ds = xr.open_dataset(self.input.input_term, **self.input.dataset_kwargs)\n\n        for attribute in self.input.attributes:\n            value = ds.attrs.get(attribute.key)\n\n            if value:\n                body[attribute.output_key] = value\n\n        return body\n</code></pre>"},{"location":"header/backends/xarray/#extraction_methods.plugins.header.backends.xarray.XarrayHeaderInput","title":"<code>XarrayHeaderInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for Xarray Header Method Input.</p> <p>Parameters:</p> Name Type Description Default <code>input_term</code> <code>str</code> <p>term for method to run on.</p> <code>'$uri'</code> <code>dataset_kwargs</code> <code>dict[str, Any]</code> <p>kwargs to open dataset.</p> <code>{}</code> <code>attributes</code> <code>list[KeyOutputKey]</code> <p>attributes to be extracted.</p> <code>[]</code> Source code in <code>extraction_methods/plugins/header/backends/xarray.py</code> <pre><code>class XarrayHeaderInput(Input):\n    \"\"\"\n    Model for Xarray Header Method Input.\n    \"\"\"\n\n    input_term: str = Field(\n        default=\"$uri\",\n        description=\"term for method to run on.\",\n    )\n    dataset_kwargs: dict[str, Any] = Field(\n        default={},\n        description=\"kwargs to open dataset.\",\n    )\n    attributes: list[KeyOutputKey] = Field(\n        default=[],\n        description=\"attributes to be extracted.\",\n    )\n</code></pre>"}]}
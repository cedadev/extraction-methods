{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Extraction Methods","text":"<p>Extraction methods provide a set of methods to extract and manipulate metadata dictionaries. The framework leverages a modular, plugin architecture to allow users to modify the workflow to fit their needs.</p>"},{"location":"assets/assets/","title":"Assets","text":"<p>..  _assets:</p>"},{"location":"assets/assets/#extraction_methods.plugins.assets.assets--stac-assets-extraction","title":"STAC Assets Extraction","text":""},{"location":"assets/assets/#extraction_methods.plugins.assets.assets.AssetExtract","title":"<code>AssetExtract</code>","text":"<p>               Bases: <code>SetEntryPointsMixin</code>, <code>ExtractionMethod</code></p> <p>Method: <code>assets</code></p> Description <p>Method to generate a dictionary of STAC Assets.</p> <p>Configuration Options: .. list-table::</p> <pre><code>- ``backend``: Backend name and inputs\n- ``extraction_methods``: Extraction methods to run on assets\n- ``output_key``: key to output to\n</code></pre> <p>Configuration Example: .. code-block:: yaml</p> <pre><code>- method: assets\n  inputs:\n    backend:\n      name: elasticsearch\n      inputs:\n        connection_kwargs:\n          hosts: ['host1:9200','host2:9200']\n    extraction_methods:\n      - method: default\n        inputs:\n          defaults:\n            hello: world\n</code></pre> Source code in <code>extraction_methods/plugins/assets/assets.py</code> <pre><code>class AssetExtract(SetEntryPointsMixin, ExtractionMethod):\n    \"\"\"\n    Method: ``assets``\n\n    Description:\n        Method to generate a dictionary of STAC Assets.\n\n    Configuration Options:\n    .. list-table::\n\n        - ``backend``: Backend name and inputs\n        - ``extraction_methods``: Extraction methods to run on assets\n        - ``output_key``: key to output to\n\n    Configuration Example:\n    .. code-block:: yaml\n\n        - method: assets\n          inputs:\n            backend:\n              name: elasticsearch\n              inputs:\n                connection_kwargs:\n                  hosts: ['host1:9200','host2:9200']\n            extraction_methods:\n              - method: default\n                inputs:\n                  defaults:\n                    hello: world\n    \"\"\"\n\n    input_class = AssetInput\n    entry_point_group: str = \"extraction_methods.assets.backends\"\n\n    @update_input\n    def run(self, body: dict[str, Any]) -&gt; dict[str, Any]:\n\n        output = {}\n        backend_entry_point = self.entry_points[self.input.backend.method].load()\n        backend = backend_entry_point(self.input.backend)\n        assets = backend._run(body)\n\n        for asset in assets:\n            for extraction_method in self.input.extraction_methods:\n                asset = extraction_method._run(asset)\n            output[asset[\"href\"]] = asset\n\n        body[self.input.output_key] = body.get(self.input.output_key, {}) | output\n\n        return body\n</code></pre>"},{"location":"assets/assets/#extraction_methods.plugins.assets.assets.AssetInput","title":"<code>AssetInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for Asset Method Input.</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>Backend</code> <p>Backend and inputs to run.</p> required <code>extraction_methods</code> <code>list[ExtractionMethodConf]</code> <p>Extraction methods to run on assets.</p> <code>[]</code> <code>output_key</code> <code>str</code> <p>term for method to output to.</p> <code>'assets'</code> Source code in <code>extraction_methods/plugins/assets/assets.py</code> <pre><code>class AssetInput(Input):\n    \"\"\"\n    Model for Asset Method Input.\n    \"\"\"\n\n    backend: Backend = Field(\n        description=\"Backend and inputs to run.\",\n    )\n    extraction_methods: list[ExtractionMethodConf] = Field(\n        default=[],\n        description=\"Extraction methods to run on assets.\",\n    )\n    output_key: str = Field(\n        default=\"assets\",\n        description=\"term for method to output to.\",\n    )\n</code></pre>"},{"location":"assets/backends/elasticsearch/","title":"Elasticsearch","text":"<p>..  _elasticsearch-assets:</p>"},{"location":"assets/backends/elasticsearch/#extraction_methods.plugins.assets.backends.elasticsearch--elasticsearch-assets-backend","title":"Elasticsearch Assets Backend","text":""},{"location":"assets/backends/elasticsearch/#extraction_methods.plugins.assets.backends.elasticsearch.ElasticsearchAssets","title":"<code>ElasticsearchAssets</code>","text":"<p>               Bases: <code>Backend</code></p> <p>Method: <code>elasticsearch_assets</code></p> Description <p>Using an ID. Generate a summary of information for higher level entities.</p> <p>Configuration Options: .. list-table::</p> <pre><code>- ``index``: Name of the index holding the STAC entities\n- ``client_kwargs``: Parameters to pass to\n  `elasticsearch.Elasticsearch&lt;https://elasticsearch-py.readthedocs.io/en/7.10.0/api.html&gt;`_\n- ``request_timeout``: Timeout for the Elasticsearch request.\n- ``body``: list of terms for which their aggregate bbox should be returned.\n- ``id_term``: Term used for agregating the STAC entities\n</code></pre> <p>Configuration Example: .. code-block:: yaml</p> <pre><code>- name: elasticsearch\n  inputs:\n    index: ceda-index\n    id_term: item_id\n    client_kwargs:\n        hosts: ['host1:9200','host2:9200']\n    fields:\n        - roles\n</code></pre> Source code in <code>extraction_methods/plugins/assets/backends/elasticsearch.py</code> <pre><code>class ElasticsearchAssets(Backend):\n    \"\"\"\n    Method: ``elasticsearch_assets``\n\n    Description:\n        Using an ID. Generate a summary of information for higher level entities.\n\n    Configuration Options:\n    .. list-table::\n\n        - ``index``: Name of the index holding the STAC entities\n        - ``client_kwargs``: Parameters to pass to\n          `elasticsearch.Elasticsearch&lt;https://elasticsearch-py.readthedocs.io/en/7.10.0/api.html&gt;`_\n        - ``request_timeout``: Timeout for the Elasticsearch request.\n        - ``body``: list of terms for which their aggregate bbox should be returned.\n        - ``id_term``: Term used for agregating the STAC entities\n\n    Configuration Example:\n    .. code-block:: yaml\n\n        - name: elasticsearch\n          inputs:\n            index: ceda-index\n            id_term: item_id\n            client_kwargs:\n                hosts: ['host1:9200','host2:9200']\n            fields:\n                - roles\n    \"\"\"\n\n    input_class = ElasticsearchAssetsInput\n\n    @update_input\n    def run(self, body: dict[str, Any]) -&gt; Iterator[dict[str, Any]]:\n\n        es = Elasticsearch_client(**self.input.client_kwargs)\n\n        # Run search\n        result = es.search(\n            index=self.input.index,\n            body=self.input.body,\n            timeout=f\"{self.input.request_timeout}s\",\n        )\n\n        for hit in result[\"hits\"][\"hits\"]:\n            source = hit[\"_source\"]\n            source[\"href\"] = source.pop(self.input.href_term)\n\n            yield source\n</code></pre>"},{"location":"assets/backends/elasticsearch/#extraction_methods.plugins.assets.backends.elasticsearch.ElasticsearchAssetsInput","title":"<code>ElasticsearchAssetsInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for Elasticsearch Assets Backend Input.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>str</code> <p>Elasticsearch index to search on.</p> required <code>client_kwargs</code> <code>dict[str, Any]</code> <p>Elasticsearch connection kwargs.</p> <code>{}</code> <code>request_timeout</code> <code>int</code> <p>Request timeout for search.</p> <code>60</code> <code>body</code> <code>dict[str, Any]</code> <p>Body for Elasticsearch search request.</p> required <code>href_term</code> <code>str</code> <p>term to use for href.</p> <code>'path'</code> Source code in <code>extraction_methods/plugins/assets/backends/elasticsearch.py</code> <pre><code>class ElasticsearchAssetsInput(Input):\n    \"\"\"\n    Model for Elasticsearch Assets Backend Input.\n    \"\"\"\n\n    index: str = Field(\n        description=\"Elasticsearch index to search on.\",\n    )\n    client_kwargs: dict[str, Any] = Field(\n        default={},\n        description=\"Elasticsearch connection kwargs.\",\n    )\n    request_timeout: int = Field(\n        default=60,\n        description=\"Request timeout for search.\",\n    )\n    body: dict[str, Any] = Field(\n        description=\"Body for Elasticsearch search request.\",\n    )\n    href_term: str = Field(\n        default=\"path\",\n        description=\"term to use for href.\",\n    )\n</code></pre>"},{"location":"assets/backends/intake_esm/","title":"Intake esm","text":"<p>..  _intake-assets:</p>"},{"location":"assets/backends/intake_esm/#extraction_methods.plugins.assets.backends.intake_esm--intake-assets-backend","title":"Intake Assets Backend","text":""},{"location":"assets/backends/intake_esm/#extraction_methods.plugins.assets.backends.intake_esm.IntakeESMAssets","title":"<code>IntakeESMAssets</code>","text":"<p>               Bases: <code>Backend</code></p> <p>Method: <code>intake_assets</code></p> Description <p>Performs Search on intake catalog to provide a stream of assets for procesing. Uses an <code>Intake catalog &lt;https://intake.readthedocs.io/&gt;</code>_ as a source for file objects.</p> <p>Configuration Options: .. list-table::</p> <pre><code>- ``input_term``: The URI of a path or URL to an ESM collection JSON\n  file. ``DEFAULT``: ``$uri``\n- ``href_term``: The column header which contains the URI to the file\n  object. ``DEFAULT``: ``path``\n- ``catalog_kwargs``: Optional kwargs to pass to `intake.open_esm_datastore\n  &lt;https://intake-esm.readthedocs.io/en/latest\n  /api.html#intake_esm.core.esm_datastore&gt;`_\n- ``search_kwargs``: Optional kwargs to pass to `esm_datastore.search\n  &lt;https://intake-esm.readthedocs.io/en/latest\n  /api.html#intake_esm.core.esm_datastore.search&gt;`_\n</code></pre> <p>Example Configuration: .. code-block:: yaml</p> <pre><code>- method: intake_esm\n  inputs:\n    href_term: url\n</code></pre> Source code in <code>extraction_methods/plugins/assets/backends/intake_esm.py</code> <pre><code>class IntakeESMAssets(Backend):\n    \"\"\"\n    Method: ``intake_assets``\n\n    Description:\n        Performs Search on intake catalog to provide a stream of assets for procesing.\n        Uses an `Intake catalog &lt;https://intake.readthedocs.io/&gt;`_\n        as a source for file objects.\n\n    Configuration Options:\n    .. list-table::\n\n        - ``input_term``: The URI of a path or URL to an ESM collection JSON\n          file. ``DEFAULT``: ``$uri``\n        - ``href_term``: The column header which contains the URI to the file\n          object. ``DEFAULT``: ``path``\n        - ``catalog_kwargs``: Optional kwargs to pass to `intake.open_esm_datastore\n          &lt;https://intake-esm.readthedocs.io/en/latest\n          /api.html#intake_esm.core.esm_datastore&gt;`_\n        - ``search_kwargs``: Optional kwargs to pass to `esm_datastore.search\n          &lt;https://intake-esm.readthedocs.io/en/latest\n          /api.html#intake_esm.core.esm_datastore.search&gt;`_\n\n    Example Configuration:\n    .. code-block:: yaml\n\n        - method: intake_esm\n          inputs:\n            href_term: url\n    \"\"\"\n\n    input_class = IntakeESMAssetsInput\n\n    @update_input\n    def run(self, body: dict[str, Any]) -&gt; Iterator[dict[str, Any]]:\n\n        catalog = intake.open_esm_datastore(\n            self.input.input_term, **self.input.datastore_kwargs\n        )\n\n        if search_kwargs := self.input.search_kwargs:\n            catalog = catalog.search(**search_kwargs)\n\n        for _, row in catalog.df.iterrows():\n            if href := getattr(row, self.input.href_term):\n                yield {\n                    \"href\": href,\n                }\n</code></pre>"},{"location":"assets/backends/intake_esm/#extraction_methods.plugins.assets.backends.intake_esm.IntakeESMAssetsInput","title":"<code>IntakeESMAssetsInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for IntakeESM Assets Backend Input.</p> <p>Parameters:</p> Name Type Description Default <code>input_term</code> <code>str</code> <p>term for method to run on.</p> <code>'$uri'</code> <code>href_term</code> <code>str</code> <p>term to use for href.</p> <code>'path'</code> <code>datastore_kwargs</code> <code>dict[str, Any]</code> <p>kwargs to open datastore.</p> <code>{}</code> <code>search_kwargs</code> <code>dict[str, Any]</code> <p>kwargs for search.</p> <code>{}</code> Source code in <code>extraction_methods/plugins/assets/backends/intake_esm.py</code> <pre><code>class IntakeESMAssetsInput(Input):\n    \"\"\"\n    Model for IntakeESM Assets Backend Input.\n    \"\"\"\n\n    input_term: str = Field(\n        default=\"$uri\",\n        description=\"term for method to run on.\",\n    )\n    href_term: str = Field(\n        default=\"path\",\n        description=\"term to use for href.\",\n    )\n    datastore_kwargs: dict[str, Any] = Field(\n        default={},\n        description=\"kwargs to open datastore.\",\n    )\n    search_kwargs: dict[str, Any] = Field(\n        default={},\n        description=\"kwargs for search.\",\n    )\n</code></pre>"},{"location":"assets/backends/regex/","title":"Regex","text":"<p>..  _regex-assets:</p>"},{"location":"assets/backends/regex/#extraction_methods.plugins.assets.backends.regex--regex-assets-backend","title":"Regex Assets Backend","text":""},{"location":"assets/backends/regex/#extraction_methods.plugins.assets.backends.regex.RegexAssets","title":"<code>RegexAssets</code>","text":"<p>               Bases: <code>Backend</code></p> <p>Method: <code>regex_assets</code></p> Description <p>Takes a regex glob and yields a dictionary for each matching path.</p> <p>Configuration Options: .. list-table::</p> <pre><code>- ``input_term``:The regular expression to match against the path\n</code></pre> <p>Example configuration: .. code-block:: yaml</p> <pre><code>- method: regex\n  inputs:\n    input_term: ^(?:[^_]*_){2}(?P&lt;datetime&gt;\\d*)\n</code></pre>"},{"location":"assets/backends/regex/#extraction_methods.plugins.assets.backends.regex.RegexAssets--noqa-w605","title":"noqa: W605","text":"Source code in <code>extraction_methods/plugins/assets/backends/regex.py</code> <pre><code>class RegexAssets(Backend):\n    \"\"\"\n    Method: ``regex_assets``\n\n    Description:\n        Takes a regex glob and yields a dictionary for each matching path.\n\n    Configuration Options:\n    .. list-table::\n\n        - ``input_term``:The regular expression to match against the path\n\n    Example configuration:\n    .. code-block:: yaml\n\n        - method: regex\n          inputs:\n            input_term: ^(?:[^_]*_){2}(?P&lt;datetime&gt;\\d*)\n\n    # noqa: W605\n    \"\"\"\n\n    input_class = RegexAssetsInput\n\n    @update_input\n    def run(self, body: dict[str, Any]) -&gt; Iterator[dict[str, Any]]:\n\n        for path in glob.iglob(self.input.input_term):\n            yield {\n                \"href\": path,\n            }\n</code></pre>"},{"location":"assets/backends/regex/#extraction_methods.plugins.assets.backends.regex.RegexAssetsInput","title":"<code>RegexAssetsInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for Regex Assets Backend Input.</p> <p>Parameters:</p> Name Type Description Default <code>input_term</code> <code>str</code> <p>term for method to run on.</p> <code>'$uri'</code> Source code in <code>extraction_methods/plugins/assets/backends/regex.py</code> <pre><code>class RegexAssetsInput(Input):\n    \"\"\"\n    Model for Regex Assets Backend Input.\n    \"\"\"\n\n    input_term: str = Field(\n        default=\"$uri\",\n        description=\"term for method to run on.\",\n    )\n</code></pre>"},{"location":"header/header/","title":"Header","text":"<p>..  _header:</p>"},{"location":"header/header/#extraction_methods.plugins.header.header--header-method","title":"Header Method","text":""},{"location":"header/header/#extraction_methods.plugins.header.header.HeaderExtract","title":"<code>HeaderExtract</code>","text":"<p>               Bases: <code>ExtractionMethod</code>, <code>SetEntryPointsMixin</code></p> <p>Method: <code>header</code></p> Description <p>Takes a header backend to run and returns the updated body from the configured backend.</p> <p>Configuration Options: .. list-table::</p> <pre><code>- ``backend``: Specify which backend\n</code></pre> <p>Example configuration: .. code-block:: yaml</p> <pre><code>- method: header\n  inputs:\n    backend:\n        name: xarray\n        inputs:\n          kwargs:\n            decode_times: False\n          attributes:\n            - name: institution\n            - name: sensor\n</code></pre> Source code in <code>extraction_methods/plugins/header/header.py</code> <pre><code>class HeaderExtract(ExtractionMethod, SetEntryPointsMixin):\n    \"\"\"\n    Method: ``header``\n\n    Description:\n        Takes a header backend to run and returns the updated body\n        from the configured backend.\n\n    Configuration Options:\n    .. list-table::\n\n        - ``backend``: Specify which backend\n\n    Example configuration:\n    .. code-block:: yaml\n\n        - method: header\n          inputs:\n            backend:\n                name: xarray\n                inputs:\n                  kwargs:\n                    decode_times: False\n                  attributes:\n                    - name: institution\n                    - name: sensor\n    \"\"\"\n\n    input_class = HeaderInput\n    entry_point_group = \"extraction_methods.header.backends\"\n\n    @update_input\n    def run(self, body: dict[str, Any]) -&gt; dict[str, Any]:\n\n        backend_entry_point = self.entry_points[self.input.backend.name].load()\n        backend = backend_entry_point(**self.input.backend.inputs)\n        body = backend._run(body)\n\n        return body\n</code></pre>"},{"location":"header/header/#extraction_methods.plugins.header.header.HeaderInput","title":"<code>HeaderInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for Header Method Input.</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>Backend</code> <p>Backend and inputs to run.</p> required Source code in <code>extraction_methods/plugins/header/header.py</code> <pre><code>class HeaderInput(Input):\n    \"\"\"\n    Model for Header Method Input.\n    \"\"\"\n\n    backend: Backend = Field(\n        description=\"Backend and inputs to run.\",\n    )\n</code></pre>"},{"location":"header/backends/cf/","title":"Cf","text":"<p>..  _cf-header:</p>"},{"location":"header/backends/cf/#extraction_methods.plugins.header.backends.cf--cf-header-backend","title":"CF Header Backend","text":""},{"location":"header/backends/cf/#extraction_methods.plugins.header.backends.cf.CfHeader","title":"<code>CfHeader</code>","text":"<p>               Bases: <code>ExtractionMethod</code></p> <p>Method: <code>cf</code></p> Description <p>CF backend for header method.</p> <p>Configuration Options: .. list-table::</p> <pre><code>- ``input_term``:term for method to run on\n- ``read_kwargs``:kwargs for cf read\n- ``attributes``:attributes to be extracted\n</code></pre> <p>Example configuration: .. code-block:: yaml</p> <pre><code>- method: cf\n  inputs:\n    input_term: hello_world\n</code></pre> Source code in <code>extraction_methods/plugins/header/backends/cf.py</code> <pre><code>class CfHeader(ExtractionMethod):\n    \"\"\"\n    Method: ``cf``\n\n    Description:\n        CF backend for header method.\n\n    Configuration Options:\n    .. list-table::\n\n        - ``input_term``:term for method to run on\n        - ``read_kwargs``:kwargs for cf read\n        - ``attributes``:attributes to be extracted\n\n    Example configuration:\n    .. code-block:: yaml\n\n        - method: cf\n          inputs:\n            input_term: hello_world\n    \"\"\"\n\n    input_class = CfHeaderInput\n\n    @update_input\n    def run(self, body: dict[str, Any]) -&gt; dict[str, Any]:\n        field_list = cf.read(self.input.input_term, **self.input.read_kwargs)\n\n        properties: dict[str, Any] = {}\n        for field in field_list:\n            properties |= field.properties()\n            if field.nc_global_attributes():\n                properties[\"global_attributes\"] = field.nc_global_attributes()\n\n        for attribute in self.input.attributes:\n            if (\n                \"global_attributes\" in properties\n                and properties[\"global_attributes\"][attribute.key]\n            ):\n                body[attribute.output_key] = properties[\"global_attributes\"][\n                    attribute.key\n                ]\n            elif attribute in properties:\n                body[attribute.output_key] = properties[attribute.key]\n\n        return body\n</code></pre>"},{"location":"header/backends/cf/#extraction_methods.plugins.header.backends.cf.CfHeaderInput","title":"<code>CfHeaderInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for CF Header Input.</p> Source code in <code>extraction_methods/plugins/header/backends/cf.py</code> <pre><code>class CfHeaderInput(Input):\n    \"\"\"\n    Model for CF Header Input.\n    \"\"\"\n\n    input_term: str = Field(\n        default=\"$uri\",\n        description=\"term for method to run on.\",\n    )\n    read_kwargs: dict[str, Any] = Field(\n        default={},\n        description=\"kwargs for cf read.\",\n    )\n    attributes: list[KeyOutputKey] = Field(\n        default=[],\n        description=\"attributes to be extracted.\",\n    )\n</code></pre>"},{"location":"header/backends/ncml/","title":"Ncml","text":"<p>..  _ncml-header:</p>"},{"location":"header/backends/ncml/#extraction_methods.plugins.header.backends.ncml--ncml-header-backend","title":"NCML Header Backend","text":""},{"location":"header/backends/ncml/#extraction_methods.plugins.header.backends.ncml.NcMLHeader","title":"<code>NcMLHeader</code>","text":"<p>               Bases: <code>ExtractionMethod</code></p> <p>Method: <code>ncml</code></p> Description <p>NcML backend for header method.</p> <p>Configuration Options: .. list-table::</p> <pre><code>- ``input_term``:term for method to run on\n- ``request_params``:params for request\n- ``namespaces``:NcML namespaces\n- ``attributes``:attributes to be extracted\n- ``request_timeout``:request time out\n</code></pre> <p>Example configuration: .. code-block:: yaml</p> <pre><code>- method: ncml\n  inputs:\n    input_term: hello_world\n</code></pre> Source code in <code>extraction_methods/plugins/header/backends/ncml.py</code> <pre><code>class NcMLHeader(ExtractionMethod):\n    \"\"\"\n    Method: ``ncml``\n\n    Description:\n        NcML backend for header method.\n\n    Configuration Options:\n    .. list-table::\n\n        - ``input_term``:term for method to run on\n        - ``request_params``:params for request\n        - ``namespaces``:NcML namespaces\n        - ``attributes``:attributes to be extracted\n        - ``request_timeout``:request time out\n\n    Example configuration:\n    .. code-block:: yaml\n\n        - method: ncml\n          inputs:\n            input_term: hello_world\n    \"\"\"\n\n    input_class = NcMLHeaderInput\n\n    def get_ncml(self) -&gt; bytes:\n        \"\"\"Get the NcML file description.\"\"\"\n\n        parse_result = urlparse(self.input.input_term)\n\n        if parse_result.netloc:\n            return self.get_ncml_from_thredds()\n\n        return self.get_ncml_from_fs()\n\n    def get_ncml_from_thredds(self) -&gt; bytes:\n        \"\"\"Read NcML response from THREDDS server.\n\n        Returns\n        -------\n        bytes\n        NcML content\n        \"\"\"\n\n        r = httpx.get(\n            self.input.input_term,\n            params=self.input.request_params,\n            timeout=self.input.request_timeout,\n        )\n        r.raise_for_status()\n        return r.content\n\n    def get_ncml_from_fs(self) -&gt; bytes:\n        \"\"\"Return NcML file description using `ncdump` utility.\"\"\"\n\n        cmd = [\"ncdump\", \"-hx\", self.input.input_term]\n        proc = subprocess.Popen(\n            cmd, stderr=subprocess.PIPE, stdout=subprocess.PIPE\n        )  # nosec B603\n        if proc.stdout:\n            return proc.stdout.read()\n        else:\n            return b\"\"\n\n    @update_input\n    def run(self, body: dict[str, Any]) -&gt; dict[str, Any]:\n        # Convert response to an XML etree.Element\n        content = self.get_ncml()\n        elemement = fromstring(\n            content, parser=XMLParser(encoding=\"UTF-8\")\n        )  # nosec B320\n\n        for attribute in self.input.attributes:\n\n            # Execute xpath expression\n            value = elemement.xpath(attribute.key, namespaces=self.input.namespaces)\n\n            if value:\n                body[attribute.output_key] = value[0]\n\n        return body\n</code></pre>"},{"location":"header/backends/ncml/#extraction_methods.plugins.header.backends.ncml.NcMLHeader.get_ncml","title":"<code>get_ncml()</code>","text":"<p>Get the NcML file description.</p> Source code in <code>extraction_methods/plugins/header/backends/ncml.py</code> <pre><code>def get_ncml(self) -&gt; bytes:\n    \"\"\"Get the NcML file description.\"\"\"\n\n    parse_result = urlparse(self.input.input_term)\n\n    if parse_result.netloc:\n        return self.get_ncml_from_thredds()\n\n    return self.get_ncml_from_fs()\n</code></pre>"},{"location":"header/backends/ncml/#extraction_methods.plugins.header.backends.ncml.NcMLHeader.get_ncml_from_fs","title":"<code>get_ncml_from_fs()</code>","text":"<p>Return NcML file description using <code>ncdump</code> utility.</p> Source code in <code>extraction_methods/plugins/header/backends/ncml.py</code> <pre><code>def get_ncml_from_fs(self) -&gt; bytes:\n    \"\"\"Return NcML file description using `ncdump` utility.\"\"\"\n\n    cmd = [\"ncdump\", \"-hx\", self.input.input_term]\n    proc = subprocess.Popen(\n        cmd, stderr=subprocess.PIPE, stdout=subprocess.PIPE\n    )  # nosec B603\n    if proc.stdout:\n        return proc.stdout.read()\n    else:\n        return b\"\"\n</code></pre>"},{"location":"header/backends/ncml/#extraction_methods.plugins.header.backends.ncml.NcMLHeader.get_ncml_from_thredds","title":"<code>get_ncml_from_thredds()</code>","text":"<p>Read NcML response from THREDDS server.</p>"},{"location":"header/backends/ncml/#extraction_methods.plugins.header.backends.ncml.NcMLHeader.get_ncml_from_thredds--returns","title":"Returns","text":"<p>bytes NcML content</p> Source code in <code>extraction_methods/plugins/header/backends/ncml.py</code> <pre><code>def get_ncml_from_thredds(self) -&gt; bytes:\n    \"\"\"Read NcML response from THREDDS server.\n\n    Returns\n    -------\n    bytes\n    NcML content\n    \"\"\"\n\n    r = httpx.get(\n        self.input.input_term,\n        params=self.input.request_params,\n        timeout=self.input.request_timeout,\n    )\n    r.raise_for_status()\n    return r.content\n</code></pre>"},{"location":"header/backends/ncml/#extraction_methods.plugins.header.backends.ncml.NcMLHeaderInput","title":"<code>NcMLHeaderInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for NcML Header Input.</p> <p>Parameters:</p> Name Type Description Default <code>input_term</code> <code>str</code> <p>term for method to run on.</p> <code>'$uri'</code> <code>request_params</code> <code>dict[str, Any]</code> <p>params for request.</p> <code>{'catalog': None, 'dataset': None}</code> <code>namespaces</code> <code>dict[str, str]</code> <p>NcML namespaces.</p> <code>{'ncml': 'http://www.unidata.ucar.edu/namespaces/netcdf/ncml-2.2'}</code> <code>attributes</code> <code>list[KeyOutputKey]</code> <p>attributes to be extracted.</p> <code>[]</code> <code>request_timeout</code> <code>int</code> <p>request time out.</p> <code>15</code> Source code in <code>extraction_methods/plugins/header/backends/ncml.py</code> <pre><code>class NcMLHeaderInput(Input):\n    \"\"\"\n    Model for NcML Header Input.\n    \"\"\"\n\n    input_term: str = Field(\n        default=\"$uri\",\n        description=\"term for method to run on.\",\n    )\n    request_params: dict[str, Any] = Field(\n        default={\"catalog\": None, \"dataset\": None},\n        description=\"params for request.\",\n    )\n    namespaces: dict[str, str] = Field(\n        default={\"ncml\": \"http://www.unidata.ucar.edu/namespaces/netcdf/ncml-2.2\"},\n        description=\"NcML namespaces.\",\n    )\n    attributes: list[KeyOutputKey] = Field(\n        default=[],\n        description=\"attributes to be extracted.\",\n    )\n    request_timeout: int = Field(\n        default=15,\n        description=\"request time out.\",\n    )\n</code></pre>"},{"location":"header/backends/xarray/","title":"Xarray","text":"<p>..  _xarray-header:</p>"},{"location":"header/backends/xarray/#extraction_methods.plugins.header.backends.xarray--xarray-header-backend","title":"Xarray Header Backend","text":""},{"location":"header/backends/xarray/#extraction_methods.plugins.header.backends.xarray.XarrayHeader","title":"<code>XarrayHeader</code>","text":"<p>               Bases: <code>ExtractionMethod</code></p> <p>Method: <code>xarray</code></p> Description <p>Xarray backend for header method.</p> <p>Configuration Options: .. list-table::</p> <pre><code>- ``input_term``:term for method to run on\n- ``dataset_kwargs``:kwargs to open dataset\n- ``attributes``:attributes to be extracted\n</code></pre> <p>Example configuration: .. code-block:: yaml</p> <pre><code>- method: xarray\n  inputs:\n    input_term: hello_world\n</code></pre> Source code in <code>extraction_methods/plugins/header/backends/xarray.py</code> <pre><code>class XarrayHeader(ExtractionMethod):\n    \"\"\"\n    Method: ``xarray``\n\n    Description:\n        Xarray backend for header method.\n\n    Configuration Options:\n    .. list-table::\n\n        - ``input_term``:term for method to run on\n        - ``dataset_kwargs``:kwargs to open dataset\n        - ``attributes``:attributes to be extracted\n\n    Example configuration:\n    .. code-block:: yaml\n\n        - method: xarray\n          inputs:\n            input_term: hello_world\n    \"\"\"\n\n    input_class = XarrayHeaderInput\n\n    @update_input\n    def run(self, body: dict[str, Any]) -&gt; dict[str, Any]:\n\n        ds = xr.open_dataset(self.input.input_term, **self.input.dataset_kwargs)\n\n        for attribute in self.input.attributes:\n            value = ds.attrs.get(attribute.key)\n\n            if value:\n                body[attribute.output_key] = value\n\n        return body\n</code></pre>"},{"location":"header/backends/xarray/#extraction_methods.plugins.header.backends.xarray.XarrayHeaderInput","title":"<code>XarrayHeaderInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Model for Xarray Header Method Input.</p> <p>Parameters:</p> Name Type Description Default <code>input_term</code> <code>str</code> <p>term for method to run on.</p> <code>'$uri'</code> <code>dataset_kwargs</code> <code>dict[str, Any]</code> <p>kwargs to open dataset.</p> <code>{}</code> <code>attributes</code> <code>list[KeyOutputKey]</code> <p>attributes to be extracted.</p> <code>[]</code> Source code in <code>extraction_methods/plugins/header/backends/xarray.py</code> <pre><code>class XarrayHeaderInput(Input):\n    \"\"\"\n    Model for Xarray Header Method Input.\n    \"\"\"\n\n    input_term: str = Field(\n        default=\"$uri\",\n        description=\"term for method to run on.\",\n    )\n    dataset_kwargs: dict[str, Any] = Field(\n        default={},\n        description=\"kwargs to open dataset.\",\n    )\n    attributes: list[KeyOutputKey] = Field(\n        default=[],\n        description=\"attributes to be extracted.\",\n    )\n</code></pre>"}]}